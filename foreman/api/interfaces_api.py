# coding: utf-8

"""
    Foreman (params in:formData)

     <p>Foreman API v2 is currently the default API version.</p> 

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from pydantic import Field
from typing_extensions import Annotated
from pydantic import StrictBool, StrictFloat, StrictInt, StrictStr, field_validator

from typing import List, Optional, Union


from foreman.api_client import ApiClient
from foreman.api_response import ApiResponse
from foreman.rest import RESTResponseType


class InterfacesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def delete_hosts_host_id_interfaces_id(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        id: Annotated[StrictStr, Field(description="ID of interface")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete a host's interface


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param id: ID of interface (required)
        :type id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_hosts_host_id_interfaces_id_serialize(
            host_id=host_id,
            id=id,
            location_id=location_id,
            organization_id=organization_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_hosts_host_id_interfaces_id_with_http_info(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        id: Annotated[StrictStr, Field(description="ID of interface")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete a host's interface


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param id: ID of interface (required)
        :type id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_hosts_host_id_interfaces_id_serialize(
            host_id=host_id,
            id=id,
            location_id=location_id,
            organization_id=organization_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_hosts_host_id_interfaces_id_without_preload_content(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        id: Annotated[StrictStr, Field(description="ID of interface")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a host's interface


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param id: ID of interface (required)
        :type id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_hosts_host_id_interfaces_id_serialize(
            host_id=host_id,
            id=id,
            location_id=location_id,
            organization_id=organization_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_hosts_host_id_interfaces_id_serialize(
        self,
        host_id,
        id,
        location_id,
        organization_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if host_id is not None:
            _path_params["host_id"] = host_id
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if location_id is not None:
            _form_params.append(("location_id", location_id))
        if organization_id is not None:
            _form_params.append(("organization_id", organization_id))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/hosts/{host_id}/interfaces/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_domains_domain_id_interfaces(
        self,
        domain_id: Annotated[StrictStr, Field(description="ID or name of domain")],
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        subnet_id: Annotated[StrictStr, Field(description="ID or name of subnet")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results per page to return, 'all' to return all results"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List all interfaces for domain


        :param domain_id: ID or name of domain (required)
        :type domain_id: str
        :param host_id: ID or name of host (required)
        :type host_id: str
        :param subnet_id: ID or name of subnet (required)
        :type subnet_id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return, 'all' to return all results
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_domains_domain_id_interfaces_serialize(
            domain_id=domain_id,
            host_id=host_id,
            subnet_id=subnet_id,
            location_id=location_id,
            organization_id=organization_id,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_domains_domain_id_interfaces_with_http_info(
        self,
        domain_id: Annotated[StrictStr, Field(description="ID or name of domain")],
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        subnet_id: Annotated[StrictStr, Field(description="ID or name of subnet")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results per page to return, 'all' to return all results"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List all interfaces for domain


        :param domain_id: ID or name of domain (required)
        :type domain_id: str
        :param host_id: ID or name of host (required)
        :type host_id: str
        :param subnet_id: ID or name of subnet (required)
        :type subnet_id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return, 'all' to return all results
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_domains_domain_id_interfaces_serialize(
            domain_id=domain_id,
            host_id=host_id,
            subnet_id=subnet_id,
            location_id=location_id,
            organization_id=organization_id,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_domains_domain_id_interfaces_without_preload_content(
        self,
        domain_id: Annotated[StrictStr, Field(description="ID or name of domain")],
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        subnet_id: Annotated[StrictStr, Field(description="ID or name of subnet")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results per page to return, 'all' to return all results"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List all interfaces for domain


        :param domain_id: ID or name of domain (required)
        :type domain_id: str
        :param host_id: ID or name of host (required)
        :type host_id: str
        :param subnet_id: ID or name of subnet (required)
        :type subnet_id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return, 'all' to return all results
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_domains_domain_id_interfaces_serialize(
            domain_id=domain_id,
            host_id=host_id,
            subnet_id=subnet_id,
            location_id=location_id,
            organization_id=organization_id,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_domains_domain_id_interfaces_serialize(
        self,
        domain_id,
        host_id,
        subnet_id,
        location_id,
        organization_id,
        page,
        per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if domain_id is not None:
            _path_params["domain_id"] = domain_id
        # process the query parameters
        if host_id is not None:
            _query_params.append(("host_id", host_id))

        if subnet_id is not None:
            _query_params.append(("subnet_id", subnet_id))

        if location_id is not None:
            _query_params.append(("location_id", location_id))

        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/domains/{domain_id}/interfaces",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_hosts_host_id_interfaces(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        domain_id: Annotated[StrictStr, Field(description="ID or name of domain")],
        subnet_id: Annotated[StrictStr, Field(description="ID or name of subnet")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results per page to return, 'all' to return all results"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List all interfaces for host


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param domain_id: ID or name of domain (required)
        :type domain_id: str
        :param subnet_id: ID or name of subnet (required)
        :type subnet_id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return, 'all' to return all results
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_hosts_host_id_interfaces_serialize(
            host_id=host_id,
            domain_id=domain_id,
            subnet_id=subnet_id,
            location_id=location_id,
            organization_id=organization_id,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_hosts_host_id_interfaces_with_http_info(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        domain_id: Annotated[StrictStr, Field(description="ID or name of domain")],
        subnet_id: Annotated[StrictStr, Field(description="ID or name of subnet")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results per page to return, 'all' to return all results"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List all interfaces for host


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param domain_id: ID or name of domain (required)
        :type domain_id: str
        :param subnet_id: ID or name of subnet (required)
        :type subnet_id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return, 'all' to return all results
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_hosts_host_id_interfaces_serialize(
            host_id=host_id,
            domain_id=domain_id,
            subnet_id=subnet_id,
            location_id=location_id,
            organization_id=organization_id,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_hosts_host_id_interfaces_without_preload_content(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        domain_id: Annotated[StrictStr, Field(description="ID or name of domain")],
        subnet_id: Annotated[StrictStr, Field(description="ID or name of subnet")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results per page to return, 'all' to return all results"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List all interfaces for host


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param domain_id: ID or name of domain (required)
        :type domain_id: str
        :param subnet_id: ID or name of subnet (required)
        :type subnet_id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return, 'all' to return all results
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_hosts_host_id_interfaces_serialize(
            host_id=host_id,
            domain_id=domain_id,
            subnet_id=subnet_id,
            location_id=location_id,
            organization_id=organization_id,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_hosts_host_id_interfaces_serialize(
        self,
        host_id,
        domain_id,
        subnet_id,
        location_id,
        organization_id,
        page,
        per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if host_id is not None:
            _path_params["host_id"] = host_id
        # process the query parameters
        if domain_id is not None:
            _query_params.append(("domain_id", domain_id))

        if subnet_id is not None:
            _query_params.append(("subnet_id", subnet_id))

        if location_id is not None:
            _query_params.append(("location_id", location_id))

        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/hosts/{host_id}/interfaces",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_hosts_host_id_interfaces_id(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        id: Annotated[StrictStr, Field(description="ID or name of interface")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Show an interface for host


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param id: ID or name of interface (required)
        :type id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_hosts_host_id_interfaces_id_serialize(
            host_id=host_id,
            id=id,
            location_id=location_id,
            organization_id=organization_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_hosts_host_id_interfaces_id_with_http_info(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        id: Annotated[StrictStr, Field(description="ID or name of interface")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Show an interface for host


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param id: ID or name of interface (required)
        :type id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_hosts_host_id_interfaces_id_serialize(
            host_id=host_id,
            id=id,
            location_id=location_id,
            organization_id=organization_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_hosts_host_id_interfaces_id_without_preload_content(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        id: Annotated[StrictStr, Field(description="ID or name of interface")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Show an interface for host


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param id: ID or name of interface (required)
        :type id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_hosts_host_id_interfaces_id_serialize(
            host_id=host_id,
            id=id,
            location_id=location_id,
            organization_id=organization_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_hosts_host_id_interfaces_id_serialize(
        self,
        host_id,
        id,
        location_id,
        organization_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if host_id is not None:
            _path_params["host_id"] = host_id
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        if location_id is not None:
            _query_params.append(("location_id", location_id))

        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/hosts/{host_id}/interfaces/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_subnets_subnet_id_interfaces(
        self,
        subnet_id: Annotated[StrictStr, Field(description="ID or name of subnet")],
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        domain_id: Annotated[StrictStr, Field(description="ID or name of domain")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results per page to return, 'all' to return all results"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List all interfaces for subnet


        :param subnet_id: ID or name of subnet (required)
        :type subnet_id: str
        :param host_id: ID or name of host (required)
        :type host_id: str
        :param domain_id: ID or name of domain (required)
        :type domain_id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return, 'all' to return all results
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_subnets_subnet_id_interfaces_serialize(
            subnet_id=subnet_id,
            host_id=host_id,
            domain_id=domain_id,
            location_id=location_id,
            organization_id=organization_id,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_subnets_subnet_id_interfaces_with_http_info(
        self,
        subnet_id: Annotated[StrictStr, Field(description="ID or name of subnet")],
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        domain_id: Annotated[StrictStr, Field(description="ID or name of domain")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results per page to return, 'all' to return all results"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List all interfaces for subnet


        :param subnet_id: ID or name of subnet (required)
        :type subnet_id: str
        :param host_id: ID or name of host (required)
        :type host_id: str
        :param domain_id: ID or name of domain (required)
        :type domain_id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return, 'all' to return all results
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_subnets_subnet_id_interfaces_serialize(
            subnet_id=subnet_id,
            host_id=host_id,
            domain_id=domain_id,
            location_id=location_id,
            organization_id=organization_id,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_subnets_subnet_id_interfaces_without_preload_content(
        self,
        subnet_id: Annotated[StrictStr, Field(description="ID or name of subnet")],
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        domain_id: Annotated[StrictStr, Field(description="ID or name of domain")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[StrictStr],
            Field(
                description="Number of results per page to return, 'all' to return all results"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List all interfaces for subnet


        :param subnet_id: ID or name of subnet (required)
        :type subnet_id: str
        :param host_id: ID or name of host (required)
        :type host_id: str
        :param domain_id: ID or name of domain (required)
        :type domain_id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return, 'all' to return all results
        :type per_page: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_subnets_subnet_id_interfaces_serialize(
            subnet_id=subnet_id,
            host_id=host_id,
            domain_id=domain_id,
            location_id=location_id,
            organization_id=organization_id,
            page=page,
            per_page=per_page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_subnets_subnet_id_interfaces_serialize(
        self,
        subnet_id,
        host_id,
        domain_id,
        location_id,
        organization_id,
        page,
        per_page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subnet_id is not None:
            _path_params["subnet_id"] = subnet_id
        # process the query parameters
        if host_id is not None:
            _query_params.append(("host_id", host_id))

        if domain_id is not None:
            _query_params.append(("domain_id", domain_id))

        if location_id is not None:
            _query_params.append(("location_id", location_id))

        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/subnets/{subnet_id}/interfaces",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def post_hosts_host_id_interfaces(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        interface_mac: Annotated[
            Optional[StrictStr],
            Field(
                description="MAC address of interface. Required for managed interfaces on bare metal."
            ),
        ] = None,
        interface_ip: Annotated[
            Optional[StrictStr], Field(description="IPv4 address of interface")
        ] = None,
        interface_ip6: Annotated[
            Optional[StrictStr], Field(description="IPv6 address of interface")
        ] = None,
        interface_type: Annotated[
            Optional[StrictStr],
            Field(description="Interface type, e.g. bmc. Default is interface"),
        ] = None,
        interface_name: Annotated[
            Optional[StrictStr], Field(description="Interface's DNS name")
        ] = None,
        interface_subnet_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Foreman subnet ID of IPv4 interface"),
        ] = None,
        interface_subnet6_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Foreman subnet ID of IPv6 interface"),
        ] = None,
        interface_domain_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Foreman domain ID of interface. Required for primary interfaces on managed hosts."
            ),
        ] = None,
        interface_identifier: Annotated[
            Optional[StrictStr],
            Field(description="Device identifier, e.g. eth0 or eth1.1"),
        ] = None,
        interface_managed: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be managed via DHCP and DNS smart proxy and should it be configured during provisioning?"
            ),
        ] = None,
        interface_primary: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be used for constructing the FQDN of the host? Each managed hosts needs to have one primary interface."
            ),
        ] = None,
        interface_provision: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be used for TFTP of PXELinux (or SSH for image-based hosts)? Each managed hosts needs to have one provision interface."
            ),
        ] = None,
        interface_username: Annotated[
            Optional[StrictStr], Field(description="Only for BMC interfaces.")
        ] = None,
        interface_password: Annotated[
            Optional[StrictStr], Field(description="Only for BMC interfaces.")
        ] = None,
        interface_provider: Annotated[
            Optional[StrictStr],
            Field(
                description="Interface provider, e.g. IPMI. Only for BMC interfaces."
            ),
        ] = None,
        interface_virtual: Annotated[
            Optional[StrictBool], Field(description="Alias or VLAN device")
        ] = None,
        interface_tag: Annotated[
            Optional[StrictStr],
            Field(
                description="VLAN tag, this attribute has precedence over the subnet VLAN ID. Only for virtual interfaces."
            ),
        ] = None,
        interface_mtu: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="MTU, this attribute has precedence over the subnet MTU."
            ),
        ] = None,
        interface_attached_to: Annotated[
            Optional[StrictStr],
            Field(
                description="Identifier of the interface to which this interface belongs, e.g. eth1. Only for virtual interfaces."
            ),
        ] = None,
        interface_mode: Annotated[
            Optional[StrictStr],
            Field(
                description="Bond mode of the interface, e.g. balance-rr. Only for bond interfaces."
            ),
        ] = None,
        interface_attached_devices: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Identifiers of attached interfaces, e.g. `['eth1', 'eth2']`. For bond interfaces those are the slaves. Only for bond and bridges interfaces."
            ),
        ] = None,
        interface_bond_options: Annotated[
            Optional[StrictStr],
            Field(
                description="Space separated options, e.g. miimon=100. Only for bond interfaces."
            ),
        ] = None,
        interface_execution: Annotated[
            Optional[StrictBool],
            Field(description="Should this interface be used for remote execution?"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Create an interface on a host


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param interface_mac: MAC address of interface. Required for managed interfaces on bare metal.
        :type interface_mac: str
        :param interface_ip: IPv4 address of interface
        :type interface_ip: str
        :param interface_ip6: IPv6 address of interface
        :type interface_ip6: str
        :param interface_type: Interface type, e.g. bmc. Default is interface
        :type interface_type: str
        :param interface_name: Interface's DNS name
        :type interface_name: str
        :param interface_subnet_id: Foreman subnet ID of IPv4 interface
        :type interface_subnet_id: float
        :param interface_subnet6_id: Foreman subnet ID of IPv6 interface
        :type interface_subnet6_id: float
        :param interface_domain_id: Foreman domain ID of interface. Required for primary interfaces on managed hosts.
        :type interface_domain_id: float
        :param interface_identifier: Device identifier, e.g. eth0 or eth1.1
        :type interface_identifier: str
        :param interface_managed: Should this interface be managed via DHCP and DNS smart proxy and should it be configured during provisioning?
        :type interface_managed: bool
        :param interface_primary: Should this interface be used for constructing the FQDN of the host? Each managed hosts needs to have one primary interface.
        :type interface_primary: bool
        :param interface_provision: Should this interface be used for TFTP of PXELinux (or SSH for image-based hosts)? Each managed hosts needs to have one provision interface.
        :type interface_provision: bool
        :param interface_username: Only for BMC interfaces.
        :type interface_username: str
        :param interface_password: Only for BMC interfaces.
        :type interface_password: str
        :param interface_provider: Interface provider, e.g. IPMI. Only for BMC interfaces.
        :type interface_provider: str
        :param interface_virtual: Alias or VLAN device
        :type interface_virtual: bool
        :param interface_tag: VLAN tag, this attribute has precedence over the subnet VLAN ID. Only for virtual interfaces.
        :type interface_tag: str
        :param interface_mtu: MTU, this attribute has precedence over the subnet MTU.
        :type interface_mtu: float
        :param interface_attached_to: Identifier of the interface to which this interface belongs, e.g. eth1. Only for virtual interfaces.
        :type interface_attached_to: str
        :param interface_mode: Bond mode of the interface, e.g. balance-rr. Only for bond interfaces.
        :type interface_mode: str
        :param interface_attached_devices: Identifiers of attached interfaces, e.g. `['eth1', 'eth2']`. For bond interfaces those are the slaves. Only for bond and bridges interfaces.
        :type interface_attached_devices: List[str]
        :param interface_bond_options: Space separated options, e.g. miimon=100. Only for bond interfaces.
        :type interface_bond_options: str
        :param interface_execution: Should this interface be used for remote execution?
        :type interface_execution: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_hosts_host_id_interfaces_serialize(
            host_id=host_id,
            location_id=location_id,
            organization_id=organization_id,
            interface_mac=interface_mac,
            interface_ip=interface_ip,
            interface_ip6=interface_ip6,
            interface_type=interface_type,
            interface_name=interface_name,
            interface_subnet_id=interface_subnet_id,
            interface_subnet6_id=interface_subnet6_id,
            interface_domain_id=interface_domain_id,
            interface_identifier=interface_identifier,
            interface_managed=interface_managed,
            interface_primary=interface_primary,
            interface_provision=interface_provision,
            interface_username=interface_username,
            interface_password=interface_password,
            interface_provider=interface_provider,
            interface_virtual=interface_virtual,
            interface_tag=interface_tag,
            interface_mtu=interface_mtu,
            interface_attached_to=interface_attached_to,
            interface_mode=interface_mode,
            interface_attached_devices=interface_attached_devices,
            interface_bond_options=interface_bond_options,
            interface_execution=interface_execution,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def post_hosts_host_id_interfaces_with_http_info(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        interface_mac: Annotated[
            Optional[StrictStr],
            Field(
                description="MAC address of interface. Required for managed interfaces on bare metal."
            ),
        ] = None,
        interface_ip: Annotated[
            Optional[StrictStr], Field(description="IPv4 address of interface")
        ] = None,
        interface_ip6: Annotated[
            Optional[StrictStr], Field(description="IPv6 address of interface")
        ] = None,
        interface_type: Annotated[
            Optional[StrictStr],
            Field(description="Interface type, e.g. bmc. Default is interface"),
        ] = None,
        interface_name: Annotated[
            Optional[StrictStr], Field(description="Interface's DNS name")
        ] = None,
        interface_subnet_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Foreman subnet ID of IPv4 interface"),
        ] = None,
        interface_subnet6_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Foreman subnet ID of IPv6 interface"),
        ] = None,
        interface_domain_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Foreman domain ID of interface. Required for primary interfaces on managed hosts."
            ),
        ] = None,
        interface_identifier: Annotated[
            Optional[StrictStr],
            Field(description="Device identifier, e.g. eth0 or eth1.1"),
        ] = None,
        interface_managed: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be managed via DHCP and DNS smart proxy and should it be configured during provisioning?"
            ),
        ] = None,
        interface_primary: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be used for constructing the FQDN of the host? Each managed hosts needs to have one primary interface."
            ),
        ] = None,
        interface_provision: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be used for TFTP of PXELinux (or SSH for image-based hosts)? Each managed hosts needs to have one provision interface."
            ),
        ] = None,
        interface_username: Annotated[
            Optional[StrictStr], Field(description="Only for BMC interfaces.")
        ] = None,
        interface_password: Annotated[
            Optional[StrictStr], Field(description="Only for BMC interfaces.")
        ] = None,
        interface_provider: Annotated[
            Optional[StrictStr],
            Field(
                description="Interface provider, e.g. IPMI. Only for BMC interfaces."
            ),
        ] = None,
        interface_virtual: Annotated[
            Optional[StrictBool], Field(description="Alias or VLAN device")
        ] = None,
        interface_tag: Annotated[
            Optional[StrictStr],
            Field(
                description="VLAN tag, this attribute has precedence over the subnet VLAN ID. Only for virtual interfaces."
            ),
        ] = None,
        interface_mtu: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="MTU, this attribute has precedence over the subnet MTU."
            ),
        ] = None,
        interface_attached_to: Annotated[
            Optional[StrictStr],
            Field(
                description="Identifier of the interface to which this interface belongs, e.g. eth1. Only for virtual interfaces."
            ),
        ] = None,
        interface_mode: Annotated[
            Optional[StrictStr],
            Field(
                description="Bond mode of the interface, e.g. balance-rr. Only for bond interfaces."
            ),
        ] = None,
        interface_attached_devices: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Identifiers of attached interfaces, e.g. `['eth1', 'eth2']`. For bond interfaces those are the slaves. Only for bond and bridges interfaces."
            ),
        ] = None,
        interface_bond_options: Annotated[
            Optional[StrictStr],
            Field(
                description="Space separated options, e.g. miimon=100. Only for bond interfaces."
            ),
        ] = None,
        interface_execution: Annotated[
            Optional[StrictBool],
            Field(description="Should this interface be used for remote execution?"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Create an interface on a host


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param interface_mac: MAC address of interface. Required for managed interfaces on bare metal.
        :type interface_mac: str
        :param interface_ip: IPv4 address of interface
        :type interface_ip: str
        :param interface_ip6: IPv6 address of interface
        :type interface_ip6: str
        :param interface_type: Interface type, e.g. bmc. Default is interface
        :type interface_type: str
        :param interface_name: Interface's DNS name
        :type interface_name: str
        :param interface_subnet_id: Foreman subnet ID of IPv4 interface
        :type interface_subnet_id: float
        :param interface_subnet6_id: Foreman subnet ID of IPv6 interface
        :type interface_subnet6_id: float
        :param interface_domain_id: Foreman domain ID of interface. Required for primary interfaces on managed hosts.
        :type interface_domain_id: float
        :param interface_identifier: Device identifier, e.g. eth0 or eth1.1
        :type interface_identifier: str
        :param interface_managed: Should this interface be managed via DHCP and DNS smart proxy and should it be configured during provisioning?
        :type interface_managed: bool
        :param interface_primary: Should this interface be used for constructing the FQDN of the host? Each managed hosts needs to have one primary interface.
        :type interface_primary: bool
        :param interface_provision: Should this interface be used for TFTP of PXELinux (or SSH for image-based hosts)? Each managed hosts needs to have one provision interface.
        :type interface_provision: bool
        :param interface_username: Only for BMC interfaces.
        :type interface_username: str
        :param interface_password: Only for BMC interfaces.
        :type interface_password: str
        :param interface_provider: Interface provider, e.g. IPMI. Only for BMC interfaces.
        :type interface_provider: str
        :param interface_virtual: Alias or VLAN device
        :type interface_virtual: bool
        :param interface_tag: VLAN tag, this attribute has precedence over the subnet VLAN ID. Only for virtual interfaces.
        :type interface_tag: str
        :param interface_mtu: MTU, this attribute has precedence over the subnet MTU.
        :type interface_mtu: float
        :param interface_attached_to: Identifier of the interface to which this interface belongs, e.g. eth1. Only for virtual interfaces.
        :type interface_attached_to: str
        :param interface_mode: Bond mode of the interface, e.g. balance-rr. Only for bond interfaces.
        :type interface_mode: str
        :param interface_attached_devices: Identifiers of attached interfaces, e.g. `['eth1', 'eth2']`. For bond interfaces those are the slaves. Only for bond and bridges interfaces.
        :type interface_attached_devices: List[str]
        :param interface_bond_options: Space separated options, e.g. miimon=100. Only for bond interfaces.
        :type interface_bond_options: str
        :param interface_execution: Should this interface be used for remote execution?
        :type interface_execution: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_hosts_host_id_interfaces_serialize(
            host_id=host_id,
            location_id=location_id,
            organization_id=organization_id,
            interface_mac=interface_mac,
            interface_ip=interface_ip,
            interface_ip6=interface_ip6,
            interface_type=interface_type,
            interface_name=interface_name,
            interface_subnet_id=interface_subnet_id,
            interface_subnet6_id=interface_subnet6_id,
            interface_domain_id=interface_domain_id,
            interface_identifier=interface_identifier,
            interface_managed=interface_managed,
            interface_primary=interface_primary,
            interface_provision=interface_provision,
            interface_username=interface_username,
            interface_password=interface_password,
            interface_provider=interface_provider,
            interface_virtual=interface_virtual,
            interface_tag=interface_tag,
            interface_mtu=interface_mtu,
            interface_attached_to=interface_attached_to,
            interface_mode=interface_mode,
            interface_attached_devices=interface_attached_devices,
            interface_bond_options=interface_bond_options,
            interface_execution=interface_execution,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def post_hosts_host_id_interfaces_without_preload_content(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        interface_mac: Annotated[
            Optional[StrictStr],
            Field(
                description="MAC address of interface. Required for managed interfaces on bare metal."
            ),
        ] = None,
        interface_ip: Annotated[
            Optional[StrictStr], Field(description="IPv4 address of interface")
        ] = None,
        interface_ip6: Annotated[
            Optional[StrictStr], Field(description="IPv6 address of interface")
        ] = None,
        interface_type: Annotated[
            Optional[StrictStr],
            Field(description="Interface type, e.g. bmc. Default is interface"),
        ] = None,
        interface_name: Annotated[
            Optional[StrictStr], Field(description="Interface's DNS name")
        ] = None,
        interface_subnet_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Foreman subnet ID of IPv4 interface"),
        ] = None,
        interface_subnet6_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Foreman subnet ID of IPv6 interface"),
        ] = None,
        interface_domain_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Foreman domain ID of interface. Required for primary interfaces on managed hosts."
            ),
        ] = None,
        interface_identifier: Annotated[
            Optional[StrictStr],
            Field(description="Device identifier, e.g. eth0 or eth1.1"),
        ] = None,
        interface_managed: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be managed via DHCP and DNS smart proxy and should it be configured during provisioning?"
            ),
        ] = None,
        interface_primary: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be used for constructing the FQDN of the host? Each managed hosts needs to have one primary interface."
            ),
        ] = None,
        interface_provision: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be used for TFTP of PXELinux (or SSH for image-based hosts)? Each managed hosts needs to have one provision interface."
            ),
        ] = None,
        interface_username: Annotated[
            Optional[StrictStr], Field(description="Only for BMC interfaces.")
        ] = None,
        interface_password: Annotated[
            Optional[StrictStr], Field(description="Only for BMC interfaces.")
        ] = None,
        interface_provider: Annotated[
            Optional[StrictStr],
            Field(
                description="Interface provider, e.g. IPMI. Only for BMC interfaces."
            ),
        ] = None,
        interface_virtual: Annotated[
            Optional[StrictBool], Field(description="Alias or VLAN device")
        ] = None,
        interface_tag: Annotated[
            Optional[StrictStr],
            Field(
                description="VLAN tag, this attribute has precedence over the subnet VLAN ID. Only for virtual interfaces."
            ),
        ] = None,
        interface_mtu: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="MTU, this attribute has precedence over the subnet MTU."
            ),
        ] = None,
        interface_attached_to: Annotated[
            Optional[StrictStr],
            Field(
                description="Identifier of the interface to which this interface belongs, e.g. eth1. Only for virtual interfaces."
            ),
        ] = None,
        interface_mode: Annotated[
            Optional[StrictStr],
            Field(
                description="Bond mode of the interface, e.g. balance-rr. Only for bond interfaces."
            ),
        ] = None,
        interface_attached_devices: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Identifiers of attached interfaces, e.g. `['eth1', 'eth2']`. For bond interfaces those are the slaves. Only for bond and bridges interfaces."
            ),
        ] = None,
        interface_bond_options: Annotated[
            Optional[StrictStr],
            Field(
                description="Space separated options, e.g. miimon=100. Only for bond interfaces."
            ),
        ] = None,
        interface_execution: Annotated[
            Optional[StrictBool],
            Field(description="Should this interface be used for remote execution?"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create an interface on a host


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param interface_mac: MAC address of interface. Required for managed interfaces on bare metal.
        :type interface_mac: str
        :param interface_ip: IPv4 address of interface
        :type interface_ip: str
        :param interface_ip6: IPv6 address of interface
        :type interface_ip6: str
        :param interface_type: Interface type, e.g. bmc. Default is interface
        :type interface_type: str
        :param interface_name: Interface's DNS name
        :type interface_name: str
        :param interface_subnet_id: Foreman subnet ID of IPv4 interface
        :type interface_subnet_id: float
        :param interface_subnet6_id: Foreman subnet ID of IPv6 interface
        :type interface_subnet6_id: float
        :param interface_domain_id: Foreman domain ID of interface. Required for primary interfaces on managed hosts.
        :type interface_domain_id: float
        :param interface_identifier: Device identifier, e.g. eth0 or eth1.1
        :type interface_identifier: str
        :param interface_managed: Should this interface be managed via DHCP and DNS smart proxy and should it be configured during provisioning?
        :type interface_managed: bool
        :param interface_primary: Should this interface be used for constructing the FQDN of the host? Each managed hosts needs to have one primary interface.
        :type interface_primary: bool
        :param interface_provision: Should this interface be used for TFTP of PXELinux (or SSH for image-based hosts)? Each managed hosts needs to have one provision interface.
        :type interface_provision: bool
        :param interface_username: Only for BMC interfaces.
        :type interface_username: str
        :param interface_password: Only for BMC interfaces.
        :type interface_password: str
        :param interface_provider: Interface provider, e.g. IPMI. Only for BMC interfaces.
        :type interface_provider: str
        :param interface_virtual: Alias or VLAN device
        :type interface_virtual: bool
        :param interface_tag: VLAN tag, this attribute has precedence over the subnet VLAN ID. Only for virtual interfaces.
        :type interface_tag: str
        :param interface_mtu: MTU, this attribute has precedence over the subnet MTU.
        :type interface_mtu: float
        :param interface_attached_to: Identifier of the interface to which this interface belongs, e.g. eth1. Only for virtual interfaces.
        :type interface_attached_to: str
        :param interface_mode: Bond mode of the interface, e.g. balance-rr. Only for bond interfaces.
        :type interface_mode: str
        :param interface_attached_devices: Identifiers of attached interfaces, e.g. `['eth1', 'eth2']`. For bond interfaces those are the slaves. Only for bond and bridges interfaces.
        :type interface_attached_devices: List[str]
        :param interface_bond_options: Space separated options, e.g. miimon=100. Only for bond interfaces.
        :type interface_bond_options: str
        :param interface_execution: Should this interface be used for remote execution?
        :type interface_execution: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_hosts_host_id_interfaces_serialize(
            host_id=host_id,
            location_id=location_id,
            organization_id=organization_id,
            interface_mac=interface_mac,
            interface_ip=interface_ip,
            interface_ip6=interface_ip6,
            interface_type=interface_type,
            interface_name=interface_name,
            interface_subnet_id=interface_subnet_id,
            interface_subnet6_id=interface_subnet6_id,
            interface_domain_id=interface_domain_id,
            interface_identifier=interface_identifier,
            interface_managed=interface_managed,
            interface_primary=interface_primary,
            interface_provision=interface_provision,
            interface_username=interface_username,
            interface_password=interface_password,
            interface_provider=interface_provider,
            interface_virtual=interface_virtual,
            interface_tag=interface_tag,
            interface_mtu=interface_mtu,
            interface_attached_to=interface_attached_to,
            interface_mode=interface_mode,
            interface_attached_devices=interface_attached_devices,
            interface_bond_options=interface_bond_options,
            interface_execution=interface_execution,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _post_hosts_host_id_interfaces_serialize(
        self,
        host_id,
        location_id,
        organization_id,
        interface_mac,
        interface_ip,
        interface_ip6,
        interface_type,
        interface_name,
        interface_subnet_id,
        interface_subnet6_id,
        interface_domain_id,
        interface_identifier,
        interface_managed,
        interface_primary,
        interface_provision,
        interface_username,
        interface_password,
        interface_provider,
        interface_virtual,
        interface_tag,
        interface_mtu,
        interface_attached_to,
        interface_mode,
        interface_attached_devices,
        interface_bond_options,
        interface_execution,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {
            "interface[attached_devices]": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if host_id is not None:
            _path_params["host_id"] = host_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if location_id is not None:
            _form_params.append(("location_id", location_id))
        if organization_id is not None:
            _form_params.append(("organization_id", organization_id))
        if interface_mac is not None:
            _form_params.append(("interface[mac]", interface_mac))
        if interface_ip is not None:
            _form_params.append(("interface[ip]", interface_ip))
        if interface_ip6 is not None:
            _form_params.append(("interface[ip6]", interface_ip6))
        if interface_type is not None:
            _form_params.append(("interface[type]", interface_type))
        if interface_name is not None:
            _form_params.append(("interface[name]", interface_name))
        if interface_subnet_id is not None:
            _form_params.append(("interface[subnet_id]", interface_subnet_id))
        if interface_subnet6_id is not None:
            _form_params.append(("interface[subnet6_id]", interface_subnet6_id))
        if interface_domain_id is not None:
            _form_params.append(("interface[domain_id]", interface_domain_id))
        if interface_identifier is not None:
            _form_params.append(("interface[identifier]", interface_identifier))
        if interface_managed is not None:
            _form_params.append(("interface[managed]", interface_managed))
        if interface_primary is not None:
            _form_params.append(("interface[primary]", interface_primary))
        if interface_provision is not None:
            _form_params.append(("interface[provision]", interface_provision))
        if interface_username is not None:
            _form_params.append(("interface[username]", interface_username))
        if interface_password is not None:
            _form_params.append(("interface[password]", interface_password))
        if interface_provider is not None:
            _form_params.append(("interface[provider]", interface_provider))
        if interface_virtual is not None:
            _form_params.append(("interface[virtual]", interface_virtual))
        if interface_tag is not None:
            _form_params.append(("interface[tag]", interface_tag))
        if interface_mtu is not None:
            _form_params.append(("interface[mtu]", interface_mtu))
        if interface_attached_to is not None:
            _form_params.append(("interface[attached_to]", interface_attached_to))
        if interface_mode is not None:
            _form_params.append(("interface[mode]", interface_mode))
        if interface_attached_devices is not None:
            _form_params.append(
                ("interface[attached_devices]", interface_attached_devices)
            )
        if interface_bond_options is not None:
            _form_params.append(("interface[bond_options]", interface_bond_options))
        if interface_execution is not None:
            _form_params.append(("interface[execution]", interface_execution))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/hosts/{host_id}/interfaces",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def put_hosts_host_id_interfaces_id(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        id: Annotated[StrictStr, Field(description="ID of interface")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        interface_mac: Annotated[
            Optional[StrictStr],
            Field(
                description="MAC address of interface. Required for managed interfaces on bare metal."
            ),
        ] = None,
        interface_ip: Annotated[
            Optional[StrictStr], Field(description="IPv4 address of interface")
        ] = None,
        interface_ip6: Annotated[
            Optional[StrictStr], Field(description="IPv6 address of interface")
        ] = None,
        interface_type: Annotated[
            Optional[StrictStr],
            Field(description="Interface type, e.g. bmc. Default is interface"),
        ] = None,
        interface_name: Annotated[
            Optional[StrictStr], Field(description="Interface's DNS name")
        ] = None,
        interface_subnet_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Foreman subnet ID of IPv4 interface"),
        ] = None,
        interface_subnet6_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Foreman subnet ID of IPv6 interface"),
        ] = None,
        interface_domain_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Foreman domain ID of interface. Required for primary interfaces on managed hosts."
            ),
        ] = None,
        interface_identifier: Annotated[
            Optional[StrictStr],
            Field(description="Device identifier, e.g. eth0 or eth1.1"),
        ] = None,
        interface_managed: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be managed via DHCP and DNS smart proxy and should it be configured during provisioning?"
            ),
        ] = None,
        interface_primary: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be used for constructing the FQDN of the host? Each managed hosts needs to have one primary interface."
            ),
        ] = None,
        interface_provision: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be used for TFTP of PXELinux (or SSH for image-based hosts)? Each managed hosts needs to have one provision interface."
            ),
        ] = None,
        interface_username: Annotated[
            Optional[StrictStr], Field(description="Only for BMC interfaces.")
        ] = None,
        interface_password: Annotated[
            Optional[StrictStr], Field(description="Only for BMC interfaces.")
        ] = None,
        interface_provider: Annotated[
            Optional[StrictStr],
            Field(
                description="Interface provider, e.g. IPMI. Only for BMC interfaces."
            ),
        ] = None,
        interface_virtual: Annotated[
            Optional[StrictBool], Field(description="Alias or VLAN device")
        ] = None,
        interface_tag: Annotated[
            Optional[StrictStr],
            Field(
                description="VLAN tag, this attribute has precedence over the subnet VLAN ID. Only for virtual interfaces."
            ),
        ] = None,
        interface_mtu: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="MTU, this attribute has precedence over the subnet MTU."
            ),
        ] = None,
        interface_attached_to: Annotated[
            Optional[StrictStr],
            Field(
                description="Identifier of the interface to which this interface belongs, e.g. eth1. Only for virtual interfaces."
            ),
        ] = None,
        interface_mode: Annotated[
            Optional[StrictStr],
            Field(
                description="Bond mode of the interface, e.g. balance-rr. Only for bond interfaces."
            ),
        ] = None,
        interface_attached_devices: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Identifiers of attached interfaces, e.g. `['eth1', 'eth2']`. For bond interfaces those are the slaves. Only for bond and bridges interfaces."
            ),
        ] = None,
        interface_bond_options: Annotated[
            Optional[StrictStr],
            Field(
                description="Space separated options, e.g. miimon=100. Only for bond interfaces."
            ),
        ] = None,
        interface_execution: Annotated[
            Optional[StrictBool],
            Field(description="Should this interface be used for remote execution?"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Update a host's interface


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param id: ID of interface (required)
        :type id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param interface_mac: MAC address of interface. Required for managed interfaces on bare metal.
        :type interface_mac: str
        :param interface_ip: IPv4 address of interface
        :type interface_ip: str
        :param interface_ip6: IPv6 address of interface
        :type interface_ip6: str
        :param interface_type: Interface type, e.g. bmc. Default is interface
        :type interface_type: str
        :param interface_name: Interface's DNS name
        :type interface_name: str
        :param interface_subnet_id: Foreman subnet ID of IPv4 interface
        :type interface_subnet_id: float
        :param interface_subnet6_id: Foreman subnet ID of IPv6 interface
        :type interface_subnet6_id: float
        :param interface_domain_id: Foreman domain ID of interface. Required for primary interfaces on managed hosts.
        :type interface_domain_id: float
        :param interface_identifier: Device identifier, e.g. eth0 or eth1.1
        :type interface_identifier: str
        :param interface_managed: Should this interface be managed via DHCP and DNS smart proxy and should it be configured during provisioning?
        :type interface_managed: bool
        :param interface_primary: Should this interface be used for constructing the FQDN of the host? Each managed hosts needs to have one primary interface.
        :type interface_primary: bool
        :param interface_provision: Should this interface be used for TFTP of PXELinux (or SSH for image-based hosts)? Each managed hosts needs to have one provision interface.
        :type interface_provision: bool
        :param interface_username: Only for BMC interfaces.
        :type interface_username: str
        :param interface_password: Only for BMC interfaces.
        :type interface_password: str
        :param interface_provider: Interface provider, e.g. IPMI. Only for BMC interfaces.
        :type interface_provider: str
        :param interface_virtual: Alias or VLAN device
        :type interface_virtual: bool
        :param interface_tag: VLAN tag, this attribute has precedence over the subnet VLAN ID. Only for virtual interfaces.
        :type interface_tag: str
        :param interface_mtu: MTU, this attribute has precedence over the subnet MTU.
        :type interface_mtu: float
        :param interface_attached_to: Identifier of the interface to which this interface belongs, e.g. eth1. Only for virtual interfaces.
        :type interface_attached_to: str
        :param interface_mode: Bond mode of the interface, e.g. balance-rr. Only for bond interfaces.
        :type interface_mode: str
        :param interface_attached_devices: Identifiers of attached interfaces, e.g. `['eth1', 'eth2']`. For bond interfaces those are the slaves. Only for bond and bridges interfaces.
        :type interface_attached_devices: List[str]
        :param interface_bond_options: Space separated options, e.g. miimon=100. Only for bond interfaces.
        :type interface_bond_options: str
        :param interface_execution: Should this interface be used for remote execution?
        :type interface_execution: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_hosts_host_id_interfaces_id_serialize(
            host_id=host_id,
            id=id,
            location_id=location_id,
            organization_id=organization_id,
            interface_mac=interface_mac,
            interface_ip=interface_ip,
            interface_ip6=interface_ip6,
            interface_type=interface_type,
            interface_name=interface_name,
            interface_subnet_id=interface_subnet_id,
            interface_subnet6_id=interface_subnet6_id,
            interface_domain_id=interface_domain_id,
            interface_identifier=interface_identifier,
            interface_managed=interface_managed,
            interface_primary=interface_primary,
            interface_provision=interface_provision,
            interface_username=interface_username,
            interface_password=interface_password,
            interface_provider=interface_provider,
            interface_virtual=interface_virtual,
            interface_tag=interface_tag,
            interface_mtu=interface_mtu,
            interface_attached_to=interface_attached_to,
            interface_mode=interface_mode,
            interface_attached_devices=interface_attached_devices,
            interface_bond_options=interface_bond_options,
            interface_execution=interface_execution,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def put_hosts_host_id_interfaces_id_with_http_info(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        id: Annotated[StrictStr, Field(description="ID of interface")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        interface_mac: Annotated[
            Optional[StrictStr],
            Field(
                description="MAC address of interface. Required for managed interfaces on bare metal."
            ),
        ] = None,
        interface_ip: Annotated[
            Optional[StrictStr], Field(description="IPv4 address of interface")
        ] = None,
        interface_ip6: Annotated[
            Optional[StrictStr], Field(description="IPv6 address of interface")
        ] = None,
        interface_type: Annotated[
            Optional[StrictStr],
            Field(description="Interface type, e.g. bmc. Default is interface"),
        ] = None,
        interface_name: Annotated[
            Optional[StrictStr], Field(description="Interface's DNS name")
        ] = None,
        interface_subnet_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Foreman subnet ID of IPv4 interface"),
        ] = None,
        interface_subnet6_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Foreman subnet ID of IPv6 interface"),
        ] = None,
        interface_domain_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Foreman domain ID of interface. Required for primary interfaces on managed hosts."
            ),
        ] = None,
        interface_identifier: Annotated[
            Optional[StrictStr],
            Field(description="Device identifier, e.g. eth0 or eth1.1"),
        ] = None,
        interface_managed: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be managed via DHCP and DNS smart proxy and should it be configured during provisioning?"
            ),
        ] = None,
        interface_primary: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be used for constructing the FQDN of the host? Each managed hosts needs to have one primary interface."
            ),
        ] = None,
        interface_provision: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be used for TFTP of PXELinux (or SSH for image-based hosts)? Each managed hosts needs to have one provision interface."
            ),
        ] = None,
        interface_username: Annotated[
            Optional[StrictStr], Field(description="Only for BMC interfaces.")
        ] = None,
        interface_password: Annotated[
            Optional[StrictStr], Field(description="Only for BMC interfaces.")
        ] = None,
        interface_provider: Annotated[
            Optional[StrictStr],
            Field(
                description="Interface provider, e.g. IPMI. Only for BMC interfaces."
            ),
        ] = None,
        interface_virtual: Annotated[
            Optional[StrictBool], Field(description="Alias or VLAN device")
        ] = None,
        interface_tag: Annotated[
            Optional[StrictStr],
            Field(
                description="VLAN tag, this attribute has precedence over the subnet VLAN ID. Only for virtual interfaces."
            ),
        ] = None,
        interface_mtu: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="MTU, this attribute has precedence over the subnet MTU."
            ),
        ] = None,
        interface_attached_to: Annotated[
            Optional[StrictStr],
            Field(
                description="Identifier of the interface to which this interface belongs, e.g. eth1. Only for virtual interfaces."
            ),
        ] = None,
        interface_mode: Annotated[
            Optional[StrictStr],
            Field(
                description="Bond mode of the interface, e.g. balance-rr. Only for bond interfaces."
            ),
        ] = None,
        interface_attached_devices: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Identifiers of attached interfaces, e.g. `['eth1', 'eth2']`. For bond interfaces those are the slaves. Only for bond and bridges interfaces."
            ),
        ] = None,
        interface_bond_options: Annotated[
            Optional[StrictStr],
            Field(
                description="Space separated options, e.g. miimon=100. Only for bond interfaces."
            ),
        ] = None,
        interface_execution: Annotated[
            Optional[StrictBool],
            Field(description="Should this interface be used for remote execution?"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Update a host's interface


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param id: ID of interface (required)
        :type id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param interface_mac: MAC address of interface. Required for managed interfaces on bare metal.
        :type interface_mac: str
        :param interface_ip: IPv4 address of interface
        :type interface_ip: str
        :param interface_ip6: IPv6 address of interface
        :type interface_ip6: str
        :param interface_type: Interface type, e.g. bmc. Default is interface
        :type interface_type: str
        :param interface_name: Interface's DNS name
        :type interface_name: str
        :param interface_subnet_id: Foreman subnet ID of IPv4 interface
        :type interface_subnet_id: float
        :param interface_subnet6_id: Foreman subnet ID of IPv6 interface
        :type interface_subnet6_id: float
        :param interface_domain_id: Foreman domain ID of interface. Required for primary interfaces on managed hosts.
        :type interface_domain_id: float
        :param interface_identifier: Device identifier, e.g. eth0 or eth1.1
        :type interface_identifier: str
        :param interface_managed: Should this interface be managed via DHCP and DNS smart proxy and should it be configured during provisioning?
        :type interface_managed: bool
        :param interface_primary: Should this interface be used for constructing the FQDN of the host? Each managed hosts needs to have one primary interface.
        :type interface_primary: bool
        :param interface_provision: Should this interface be used for TFTP of PXELinux (or SSH for image-based hosts)? Each managed hosts needs to have one provision interface.
        :type interface_provision: bool
        :param interface_username: Only for BMC interfaces.
        :type interface_username: str
        :param interface_password: Only for BMC interfaces.
        :type interface_password: str
        :param interface_provider: Interface provider, e.g. IPMI. Only for BMC interfaces.
        :type interface_provider: str
        :param interface_virtual: Alias or VLAN device
        :type interface_virtual: bool
        :param interface_tag: VLAN tag, this attribute has precedence over the subnet VLAN ID. Only for virtual interfaces.
        :type interface_tag: str
        :param interface_mtu: MTU, this attribute has precedence over the subnet MTU.
        :type interface_mtu: float
        :param interface_attached_to: Identifier of the interface to which this interface belongs, e.g. eth1. Only for virtual interfaces.
        :type interface_attached_to: str
        :param interface_mode: Bond mode of the interface, e.g. balance-rr. Only for bond interfaces.
        :type interface_mode: str
        :param interface_attached_devices: Identifiers of attached interfaces, e.g. `['eth1', 'eth2']`. For bond interfaces those are the slaves. Only for bond and bridges interfaces.
        :type interface_attached_devices: List[str]
        :param interface_bond_options: Space separated options, e.g. miimon=100. Only for bond interfaces.
        :type interface_bond_options: str
        :param interface_execution: Should this interface be used for remote execution?
        :type interface_execution: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_hosts_host_id_interfaces_id_serialize(
            host_id=host_id,
            id=id,
            location_id=location_id,
            organization_id=organization_id,
            interface_mac=interface_mac,
            interface_ip=interface_ip,
            interface_ip6=interface_ip6,
            interface_type=interface_type,
            interface_name=interface_name,
            interface_subnet_id=interface_subnet_id,
            interface_subnet6_id=interface_subnet6_id,
            interface_domain_id=interface_domain_id,
            interface_identifier=interface_identifier,
            interface_managed=interface_managed,
            interface_primary=interface_primary,
            interface_provision=interface_provision,
            interface_username=interface_username,
            interface_password=interface_password,
            interface_provider=interface_provider,
            interface_virtual=interface_virtual,
            interface_tag=interface_tag,
            interface_mtu=interface_mtu,
            interface_attached_to=interface_attached_to,
            interface_mode=interface_mode,
            interface_attached_devices=interface_attached_devices,
            interface_bond_options=interface_bond_options,
            interface_execution=interface_execution,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def put_hosts_host_id_interfaces_id_without_preload_content(
        self,
        host_id: Annotated[StrictStr, Field(description="ID or name of host")],
        id: Annotated[StrictStr, Field(description="ID of interface")],
        location_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current location context for the request"),
        ] = None,
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Set the current organization context for the request"),
        ] = None,
        interface_mac: Annotated[
            Optional[StrictStr],
            Field(
                description="MAC address of interface. Required for managed interfaces on bare metal."
            ),
        ] = None,
        interface_ip: Annotated[
            Optional[StrictStr], Field(description="IPv4 address of interface")
        ] = None,
        interface_ip6: Annotated[
            Optional[StrictStr], Field(description="IPv6 address of interface")
        ] = None,
        interface_type: Annotated[
            Optional[StrictStr],
            Field(description="Interface type, e.g. bmc. Default is interface"),
        ] = None,
        interface_name: Annotated[
            Optional[StrictStr], Field(description="Interface's DNS name")
        ] = None,
        interface_subnet_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Foreman subnet ID of IPv4 interface"),
        ] = None,
        interface_subnet6_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Foreman subnet ID of IPv6 interface"),
        ] = None,
        interface_domain_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Foreman domain ID of interface. Required for primary interfaces on managed hosts."
            ),
        ] = None,
        interface_identifier: Annotated[
            Optional[StrictStr],
            Field(description="Device identifier, e.g. eth0 or eth1.1"),
        ] = None,
        interface_managed: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be managed via DHCP and DNS smart proxy and should it be configured during provisioning?"
            ),
        ] = None,
        interface_primary: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be used for constructing the FQDN of the host? Each managed hosts needs to have one primary interface."
            ),
        ] = None,
        interface_provision: Annotated[
            Optional[StrictBool],
            Field(
                description="Should this interface be used for TFTP of PXELinux (or SSH for image-based hosts)? Each managed hosts needs to have one provision interface."
            ),
        ] = None,
        interface_username: Annotated[
            Optional[StrictStr], Field(description="Only for BMC interfaces.")
        ] = None,
        interface_password: Annotated[
            Optional[StrictStr], Field(description="Only for BMC interfaces.")
        ] = None,
        interface_provider: Annotated[
            Optional[StrictStr],
            Field(
                description="Interface provider, e.g. IPMI. Only for BMC interfaces."
            ),
        ] = None,
        interface_virtual: Annotated[
            Optional[StrictBool], Field(description="Alias or VLAN device")
        ] = None,
        interface_tag: Annotated[
            Optional[StrictStr],
            Field(
                description="VLAN tag, this attribute has precedence over the subnet VLAN ID. Only for virtual interfaces."
            ),
        ] = None,
        interface_mtu: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="MTU, this attribute has precedence over the subnet MTU."
            ),
        ] = None,
        interface_attached_to: Annotated[
            Optional[StrictStr],
            Field(
                description="Identifier of the interface to which this interface belongs, e.g. eth1. Only for virtual interfaces."
            ),
        ] = None,
        interface_mode: Annotated[
            Optional[StrictStr],
            Field(
                description="Bond mode of the interface, e.g. balance-rr. Only for bond interfaces."
            ),
        ] = None,
        interface_attached_devices: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Identifiers of attached interfaces, e.g. `['eth1', 'eth2']`. For bond interfaces those are the slaves. Only for bond and bridges interfaces."
            ),
        ] = None,
        interface_bond_options: Annotated[
            Optional[StrictStr],
            Field(
                description="Space separated options, e.g. miimon=100. Only for bond interfaces."
            ),
        ] = None,
        interface_execution: Annotated[
            Optional[StrictBool],
            Field(description="Should this interface be used for remote execution?"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update a host's interface


        :param host_id: ID or name of host (required)
        :type host_id: str
        :param id: ID of interface (required)
        :type id: str
        :param location_id: Set the current location context for the request
        :type location_id: float
        :param organization_id: Set the current organization context for the request
        :type organization_id: float
        :param interface_mac: MAC address of interface. Required for managed interfaces on bare metal.
        :type interface_mac: str
        :param interface_ip: IPv4 address of interface
        :type interface_ip: str
        :param interface_ip6: IPv6 address of interface
        :type interface_ip6: str
        :param interface_type: Interface type, e.g. bmc. Default is interface
        :type interface_type: str
        :param interface_name: Interface's DNS name
        :type interface_name: str
        :param interface_subnet_id: Foreman subnet ID of IPv4 interface
        :type interface_subnet_id: float
        :param interface_subnet6_id: Foreman subnet ID of IPv6 interface
        :type interface_subnet6_id: float
        :param interface_domain_id: Foreman domain ID of interface. Required for primary interfaces on managed hosts.
        :type interface_domain_id: float
        :param interface_identifier: Device identifier, e.g. eth0 or eth1.1
        :type interface_identifier: str
        :param interface_managed: Should this interface be managed via DHCP and DNS smart proxy and should it be configured during provisioning?
        :type interface_managed: bool
        :param interface_primary: Should this interface be used for constructing the FQDN of the host? Each managed hosts needs to have one primary interface.
        :type interface_primary: bool
        :param interface_provision: Should this interface be used for TFTP of PXELinux (or SSH for image-based hosts)? Each managed hosts needs to have one provision interface.
        :type interface_provision: bool
        :param interface_username: Only for BMC interfaces.
        :type interface_username: str
        :param interface_password: Only for BMC interfaces.
        :type interface_password: str
        :param interface_provider: Interface provider, e.g. IPMI. Only for BMC interfaces.
        :type interface_provider: str
        :param interface_virtual: Alias or VLAN device
        :type interface_virtual: bool
        :param interface_tag: VLAN tag, this attribute has precedence over the subnet VLAN ID. Only for virtual interfaces.
        :type interface_tag: str
        :param interface_mtu: MTU, this attribute has precedence over the subnet MTU.
        :type interface_mtu: float
        :param interface_attached_to: Identifier of the interface to which this interface belongs, e.g. eth1. Only for virtual interfaces.
        :type interface_attached_to: str
        :param interface_mode: Bond mode of the interface, e.g. balance-rr. Only for bond interfaces.
        :type interface_mode: str
        :param interface_attached_devices: Identifiers of attached interfaces, e.g. `['eth1', 'eth2']`. For bond interfaces those are the slaves. Only for bond and bridges interfaces.
        :type interface_attached_devices: List[str]
        :param interface_bond_options: Space separated options, e.g. miimon=100. Only for bond interfaces.
        :type interface_bond_options: str
        :param interface_execution: Should this interface be used for remote execution?
        :type interface_execution: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_hosts_host_id_interfaces_id_serialize(
            host_id=host_id,
            id=id,
            location_id=location_id,
            organization_id=organization_id,
            interface_mac=interface_mac,
            interface_ip=interface_ip,
            interface_ip6=interface_ip6,
            interface_type=interface_type,
            interface_name=interface_name,
            interface_subnet_id=interface_subnet_id,
            interface_subnet6_id=interface_subnet6_id,
            interface_domain_id=interface_domain_id,
            interface_identifier=interface_identifier,
            interface_managed=interface_managed,
            interface_primary=interface_primary,
            interface_provision=interface_provision,
            interface_username=interface_username,
            interface_password=interface_password,
            interface_provider=interface_provider,
            interface_virtual=interface_virtual,
            interface_tag=interface_tag,
            interface_mtu=interface_mtu,
            interface_attached_to=interface_attached_to,
            interface_mode=interface_mode,
            interface_attached_devices=interface_attached_devices,
            interface_bond_options=interface_bond_options,
            interface_execution=interface_execution,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _put_hosts_host_id_interfaces_id_serialize(
        self,
        host_id,
        id,
        location_id,
        organization_id,
        interface_mac,
        interface_ip,
        interface_ip6,
        interface_type,
        interface_name,
        interface_subnet_id,
        interface_subnet6_id,
        interface_domain_id,
        interface_identifier,
        interface_managed,
        interface_primary,
        interface_provision,
        interface_username,
        interface_password,
        interface_provider,
        interface_virtual,
        interface_tag,
        interface_mtu,
        interface_attached_to,
        interface_mode,
        interface_attached_devices,
        interface_bond_options,
        interface_execution,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {
            "interface[attached_devices]": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if host_id is not None:
            _path_params["host_id"] = host_id
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if location_id is not None:
            _form_params.append(("location_id", location_id))
        if organization_id is not None:
            _form_params.append(("organization_id", organization_id))
        if interface_mac is not None:
            _form_params.append(("interface[mac]", interface_mac))
        if interface_ip is not None:
            _form_params.append(("interface[ip]", interface_ip))
        if interface_ip6 is not None:
            _form_params.append(("interface[ip6]", interface_ip6))
        if interface_type is not None:
            _form_params.append(("interface[type]", interface_type))
        if interface_name is not None:
            _form_params.append(("interface[name]", interface_name))
        if interface_subnet_id is not None:
            _form_params.append(("interface[subnet_id]", interface_subnet_id))
        if interface_subnet6_id is not None:
            _form_params.append(("interface[subnet6_id]", interface_subnet6_id))
        if interface_domain_id is not None:
            _form_params.append(("interface[domain_id]", interface_domain_id))
        if interface_identifier is not None:
            _form_params.append(("interface[identifier]", interface_identifier))
        if interface_managed is not None:
            _form_params.append(("interface[managed]", interface_managed))
        if interface_primary is not None:
            _form_params.append(("interface[primary]", interface_primary))
        if interface_provision is not None:
            _form_params.append(("interface[provision]", interface_provision))
        if interface_username is not None:
            _form_params.append(("interface[username]", interface_username))
        if interface_password is not None:
            _form_params.append(("interface[password]", interface_password))
        if interface_provider is not None:
            _form_params.append(("interface[provider]", interface_provider))
        if interface_virtual is not None:
            _form_params.append(("interface[virtual]", interface_virtual))
        if interface_tag is not None:
            _form_params.append(("interface[tag]", interface_tag))
        if interface_mtu is not None:
            _form_params.append(("interface[mtu]", interface_mtu))
        if interface_attached_to is not None:
            _form_params.append(("interface[attached_to]", interface_attached_to))
        if interface_mode is not None:
            _form_params.append(("interface[mode]", interface_mode))
        if interface_attached_devices is not None:
            _form_params.append(
                ("interface[attached_devices]", interface_attached_devices)
            )
        if interface_bond_options is not None:
            _form_params.append(("interface[bond_options]", interface_bond_options))
        if interface_execution is not None:
            _form_params.append(("interface[execution]", interface_execution))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/hosts/{host_id}/interfaces/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
