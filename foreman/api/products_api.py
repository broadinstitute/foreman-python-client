# coding: utf-8

"""
    Foreman (params in:formData)

     <p>Foreman API v2 is currently the default API version.</p> 

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from pydantic import Field
from typing_extensions import Annotated
from pydantic import StrictBool, StrictFloat, StrictInt, StrictStr

from typing import Optional, Union


from foreman.api_client import ApiClient
from foreman.api_response import ApiResponse
from foreman.rest import RESTResponseType


class ProductsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def delete_products_id(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="product numeric identifier"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Destroy a product


        :param id: product numeric identifier (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_products_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_products_id_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="product numeric identifier"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Destroy a product


        :param id: product numeric identifier (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_products_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_products_id_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="product numeric identifier"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Destroy a product


        :param id: product numeric identifier (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_products_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_products_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/products/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_activation_keys_activation_key_id_products(
        self,
        activation_key_id: Union[StrictFloat, StrictInt],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List of subscription products in an activation key


        :param activation_key_id: (required)
        :type activation_key_id: float
        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_activation_keys_activation_key_id_products_serialize(
            activation_key_id=activation_key_id,
            organization_id=organization_id,
            subscription_id=subscription_id,
            sync_plan_id=sync_plan_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_activation_keys_activation_key_id_products_with_http_info(
        self,
        activation_key_id: Union[StrictFloat, StrictInt],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List of subscription products in an activation key


        :param activation_key_id: (required)
        :type activation_key_id: float
        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_activation_keys_activation_key_id_products_serialize(
            activation_key_id=activation_key_id,
            organization_id=organization_id,
            subscription_id=subscription_id,
            sync_plan_id=sync_plan_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_activation_keys_activation_key_id_products_without_preload_content(
        self,
        activation_key_id: Union[StrictFloat, StrictInt],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of subscription products in an activation key


        :param activation_key_id: (required)
        :type activation_key_id: float
        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_activation_keys_activation_key_id_products_serialize(
            activation_key_id=activation_key_id,
            organization_id=organization_id,
            subscription_id=subscription_id,
            sync_plan_id=sync_plan_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_activation_keys_activation_key_id_products_serialize(
        self,
        activation_key_id,
        organization_id,
        subscription_id,
        sync_plan_id,
        name,
        enabled,
        custom,
        redhat_only,
        include_available_content,
        available_for,
        search,
        page,
        per_page,
        order,
        full_result,
        sort_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if activation_key_id is not None:
            _path_params["activation_key_id"] = activation_key_id
        # process the query parameters
        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        if subscription_id is not None:
            _query_params.append(("subscription_id", subscription_id))

        if sync_plan_id is not None:
            _query_params.append(("sync_plan_id", sync_plan_id))

        if name is not None:
            _query_params.append(("name", name))

        if enabled is not None:
            _query_params.append(("enabled", enabled))

        if custom is not None:
            _query_params.append(("custom", custom))

        if redhat_only is not None:
            _query_params.append(("redhat_only", redhat_only))

        if include_available_content is not None:
            _query_params.append(
                ("include_available_content", include_available_content)
            )

        if available_for is not None:
            _query_params.append(("available_for", available_for))

        if search is not None:
            _query_params.append(("search", search))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order is not None:
            _query_params.append(("order", order))

        if full_result is not None:
            _query_params.append(("full_result", full_result))

        if sort_by is not None:
            _query_params.append(("sort_by", sort_by))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/activation_keys/{activation_key_id}/products",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_organizations_organization_id_products(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List of products in an organization


        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_organizations_organization_id_products_serialize(
            organization_id=organization_id,
            subscription_id=subscription_id,
            sync_plan_id=sync_plan_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_organizations_organization_id_products_with_http_info(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List of products in an organization


        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_organizations_organization_id_products_serialize(
            organization_id=organization_id,
            subscription_id=subscription_id,
            sync_plan_id=sync_plan_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_organizations_organization_id_products_without_preload_content(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of products in an organization


        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_organizations_organization_id_products_serialize(
            organization_id=organization_id,
            subscription_id=subscription_id,
            sync_plan_id=sync_plan_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_organizations_organization_id_products_serialize(
        self,
        organization_id,
        subscription_id,
        sync_plan_id,
        name,
        enabled,
        custom,
        redhat_only,
        include_available_content,
        available_for,
        search,
        page,
        per_page,
        order,
        full_result,
        sort_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if organization_id is not None:
            _path_params["organization_id"] = organization_id
        # process the query parameters
        if subscription_id is not None:
            _query_params.append(("subscription_id", subscription_id))

        if sync_plan_id is not None:
            _query_params.append(("sync_plan_id", sync_plan_id))

        if name is not None:
            _query_params.append(("name", name))

        if enabled is not None:
            _query_params.append(("enabled", enabled))

        if custom is not None:
            _query_params.append(("custom", custom))

        if redhat_only is not None:
            _query_params.append(("redhat_only", redhat_only))

        if include_available_content is not None:
            _query_params.append(
                ("include_available_content", include_available_content)
            )

        if available_for is not None:
            _query_params.append(("available_for", available_for))

        if search is not None:
            _query_params.append(("search", search))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order is not None:
            _query_params.append(("order", order))

        if full_result is not None:
            _query_params.append(("full_result", full_result))

        if sort_by is not None:
            _query_params.append(("sort_by", sort_by))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/organizations/{organization_id}/products",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_organizations_organization_id_sync_plans_sync_plan_id_products(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List of Products for sync plan


        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_organizations_organization_id_sync_plans_sync_plan_id_products_serialize(
            organization_id=organization_id,
            sync_plan_id=sync_plan_id,
            subscription_id=subscription_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_organizations_organization_id_sync_plans_sync_plan_id_products_with_http_info(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List of Products for sync plan


        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_organizations_organization_id_sync_plans_sync_plan_id_products_serialize(
            organization_id=organization_id,
            sync_plan_id=sync_plan_id,
            subscription_id=subscription_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_organizations_organization_id_sync_plans_sync_plan_id_products_without_preload_content(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of Products for sync plan


        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_organizations_organization_id_sync_plans_sync_plan_id_products_serialize(
            organization_id=organization_id,
            sync_plan_id=sync_plan_id,
            subscription_id=subscription_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_organizations_organization_id_sync_plans_sync_plan_id_products_serialize(
        self,
        organization_id,
        sync_plan_id,
        subscription_id,
        name,
        enabled,
        custom,
        redhat_only,
        include_available_content,
        available_for,
        search,
        page,
        per_page,
        order,
        full_result,
        sort_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if organization_id is not None:
            _path_params["organization_id"] = organization_id
        if sync_plan_id is not None:
            _path_params["sync_plan_id"] = sync_plan_id
        # process the query parameters
        if subscription_id is not None:
            _query_params.append(("subscription_id", subscription_id))

        if name is not None:
            _query_params.append(("name", name))

        if enabled is not None:
            _query_params.append(("enabled", enabled))

        if custom is not None:
            _query_params.append(("custom", custom))

        if redhat_only is not None:
            _query_params.append(("redhat_only", redhat_only))

        if include_available_content is not None:
            _query_params.append(
                ("include_available_content", include_available_content)
            )

        if available_for is not None:
            _query_params.append(("available_for", available_for))

        if search is not None:
            _query_params.append(("search", search))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order is not None:
            _query_params.append(("order", order))

        if full_result is not None:
            _query_params.append(("full_result", full_result))

        if sort_by is not None:
            _query_params.append(("sort_by", sort_by))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/organizations/{organization_id}/sync_plans/{sync_plan_id}/products",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_products(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List products


        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_products_serialize(
            organization_id=organization_id,
            subscription_id=subscription_id,
            sync_plan_id=sync_plan_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_products_with_http_info(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List products


        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_products_serialize(
            organization_id=organization_id,
            subscription_id=subscription_id,
            sync_plan_id=sync_plan_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_products_without_preload_content(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List products


        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_products_serialize(
            organization_id=organization_id,
            subscription_id=subscription_id,
            sync_plan_id=sync_plan_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_products_serialize(
        self,
        organization_id,
        subscription_id,
        sync_plan_id,
        name,
        enabled,
        custom,
        redhat_only,
        include_available_content,
        available_for,
        search,
        page,
        per_page,
        order,
        full_result,
        sort_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        if subscription_id is not None:
            _query_params.append(("subscription_id", subscription_id))

        if sync_plan_id is not None:
            _query_params.append(("sync_plan_id", sync_plan_id))

        if name is not None:
            _query_params.append(("name", name))

        if enabled is not None:
            _query_params.append(("enabled", enabled))

        if custom is not None:
            _query_params.append(("custom", custom))

        if redhat_only is not None:
            _query_params.append(("redhat_only", redhat_only))

        if include_available_content is not None:
            _query_params.append(
                ("include_available_content", include_available_content)
            )

        if available_for is not None:
            _query_params.append(("available_for", available_for))

        if search is not None:
            _query_params.append(("search", search))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order is not None:
            _query_params.append(("order", order))

        if full_result is not None:
            _query_params.append(("full_result", full_result))

        if sort_by is not None:
            _query_params.append(("sort_by", sort_by))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/products",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_products_id(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="product numeric identifier"),
        ],
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Organization ID"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Show a product


        :param id: product numeric identifier (required)
        :type id: float
        :param organization_id: Organization ID
        :type organization_id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_products_id_serialize(
            id=id,
            organization_id=organization_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_products_id_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="product numeric identifier"),
        ],
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Organization ID"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Show a product


        :param id: product numeric identifier (required)
        :type id: float
        :param organization_id: Organization ID
        :type organization_id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_products_id_serialize(
            id=id,
            organization_id=organization_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_products_id_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="product numeric identifier"),
        ],
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Organization ID"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Show a product


        :param id: product numeric identifier (required)
        :type id: float
        :param organization_id: Organization ID
        :type organization_id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_products_id_serialize(
            id=id,
            organization_id=organization_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_products_id_serialize(
        self,
        id,
        organization_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/products/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_subscriptions_subscription_id_products(
        self,
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List of subscription products in a subscription


        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_subscriptions_subscription_id_products_serialize(
            subscription_id=subscription_id,
            organization_id=organization_id,
            sync_plan_id=sync_plan_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_subscriptions_subscription_id_products_with_http_info(
        self,
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List of subscription products in a subscription


        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_subscriptions_subscription_id_products_serialize(
            subscription_id=subscription_id,
            organization_id=organization_id,
            sync_plan_id=sync_plan_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_subscriptions_subscription_id_products_without_preload_content(
        self,
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of subscription products in a subscription


        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_subscriptions_subscription_id_products_serialize(
            subscription_id=subscription_id,
            organization_id=organization_id,
            sync_plan_id=sync_plan_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_subscriptions_subscription_id_products_serialize(
        self,
        subscription_id,
        organization_id,
        sync_plan_id,
        name,
        enabled,
        custom,
        redhat_only,
        include_available_content,
        available_for,
        search,
        page,
        per_page,
        order,
        full_result,
        sort_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription_id is not None:
            _path_params["subscription_id"] = subscription_id
        # process the query parameters
        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        if sync_plan_id is not None:
            _query_params.append(("sync_plan_id", sync_plan_id))

        if name is not None:
            _query_params.append(("name", name))

        if enabled is not None:
            _query_params.append(("enabled", enabled))

        if custom is not None:
            _query_params.append(("custom", custom))

        if redhat_only is not None:
            _query_params.append(("redhat_only", redhat_only))

        if include_available_content is not None:
            _query_params.append(
                ("include_available_content", include_available_content)
            )

        if available_for is not None:
            _query_params.append(("available_for", available_for))

        if search is not None:
            _query_params.append(("search", search))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order is not None:
            _query_params.append(("order", order))

        if full_result is not None:
            _query_params.append(("full_result", full_result))

        if sort_by is not None:
            _query_params.append(("sort_by", sort_by))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/subscriptions/{subscription_id}/products",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_sync_plans_sync_plan_id_products(
        self,
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List of Products for sync plan


        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_sync_plans_sync_plan_id_products_serialize(
            sync_plan_id=sync_plan_id,
            organization_id=organization_id,
            subscription_id=subscription_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_sync_plans_sync_plan_id_products_with_http_info(
        self,
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List of Products for sync plan


        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_sync_plans_sync_plan_id_products_serialize(
            sync_plan_id=sync_plan_id,
            organization_id=organization_id,
            subscription_id=subscription_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_sync_plans_sync_plan_id_products_without_preload_content(
        self,
        sync_plan_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by sync plan id"),
        ],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by organization"),
        ],
        subscription_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Filter products by subscription"),
        ],
        name: Annotated[
            Optional[StrictStr], Field(description="Filter products by name")
        ] = None,
        enabled: Annotated[
            Optional[StrictBool], Field(description="Return enabled products only")
        ] = None,
        custom: Annotated[
            Optional[StrictBool], Field(description="Return custom products only")
        ] = None,
        redhat_only: Annotated[
            Optional[StrictBool],
            Field(description="Return Red Hat (non-custom) products only"),
        ] = None,
        include_available_content: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether to include available content attribute in results"
            ),
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported."
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of Products for sync plan


        :param sync_plan_id: Filter products by sync plan id (required)
        :type sync_plan_id: float
        :param organization_id: Filter products by organization (required)
        :type organization_id: float
        :param subscription_id: Filter products by subscription (required)
        :type subscription_id: float
        :param name: Filter products by name
        :type name: str
        :param enabled: Return enabled products only
        :type enabled: bool
        :param custom: Return custom products only
        :type custom: bool
        :param redhat_only: Return Red Hat (non-custom) products only
        :type redhat_only: bool
        :param include_available_content: Whether to include available content attribute in results
        :type include_available_content: bool
        :param available_for: Interpret specified object to return only Products that can be associated with specified object.  Only 'sync_plan' is supported.
        :type available_for: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_sync_plans_sync_plan_id_products_serialize(
            sync_plan_id=sync_plan_id,
            organization_id=organization_id,
            subscription_id=subscription_id,
            name=name,
            enabled=enabled,
            custom=custom,
            redhat_only=redhat_only,
            include_available_content=include_available_content,
            available_for=available_for,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_sync_plans_sync_plan_id_products_serialize(
        self,
        sync_plan_id,
        organization_id,
        subscription_id,
        name,
        enabled,
        custom,
        redhat_only,
        include_available_content,
        available_for,
        search,
        page,
        per_page,
        order,
        full_result,
        sort_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if sync_plan_id is not None:
            _path_params["sync_plan_id"] = sync_plan_id
        # process the query parameters
        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        if subscription_id is not None:
            _query_params.append(("subscription_id", subscription_id))

        if name is not None:
            _query_params.append(("name", name))

        if enabled is not None:
            _query_params.append(("enabled", enabled))

        if custom is not None:
            _query_params.append(("custom", custom))

        if redhat_only is not None:
            _query_params.append(("redhat_only", redhat_only))

        if include_available_content is not None:
            _query_params.append(
                ("include_available_content", include_available_content)
            )

        if available_for is not None:
            _query_params.append(("available_for", available_for))

        if search is not None:
            _query_params.append(("search", search))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order is not None:
            _query_params.append(("order", order))

        if full_result is not None:
            _query_params.append(("full_result", full_result))

        if sort_by is not None:
            _query_params.append(("sort_by", sort_by))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/sync_plans/{sync_plan_id}/products",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def post_products(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="ID of the organization")
        ],
        name: Annotated[StrictStr, Field(description="Product name")],
        description: Annotated[
            Optional[StrictStr], Field(description="Product description")
        ] = None,
        gpg_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the GPG key"),
        ] = None,
        ssl_ca_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Idenifier of the SSL CA Cert"),
        ] = None,
        ssl_client_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the SSL Client Cert"),
        ] = None,
        ssl_client_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the SSL Client Key"),
        ] = None,
        sync_plan_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Plan numeric identifier"),
        ] = None,
        label: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Create a product


        :param organization_id: ID of the organization (required)
        :type organization_id: float
        :param name: Product name (required)
        :type name: str
        :param description: Product description
        :type description: str
        :param gpg_key_id: Identifier of the GPG key
        :type gpg_key_id: float
        :param ssl_ca_cert_id: Idenifier of the SSL CA Cert
        :type ssl_ca_cert_id: float
        :param ssl_client_cert_id: Identifier of the SSL Client Cert
        :type ssl_client_cert_id: float
        :param ssl_client_key_id: Identifier of the SSL Client Key
        :type ssl_client_key_id: float
        :param sync_plan_id: Plan numeric identifier
        :type sync_plan_id: float
        :param label:
        :type label: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_products_serialize(
            organization_id=organization_id,
            name=name,
            description=description,
            gpg_key_id=gpg_key_id,
            ssl_ca_cert_id=ssl_ca_cert_id,
            ssl_client_cert_id=ssl_client_cert_id,
            ssl_client_key_id=ssl_client_key_id,
            sync_plan_id=sync_plan_id,
            label=label,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def post_products_with_http_info(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="ID of the organization")
        ],
        name: Annotated[StrictStr, Field(description="Product name")],
        description: Annotated[
            Optional[StrictStr], Field(description="Product description")
        ] = None,
        gpg_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the GPG key"),
        ] = None,
        ssl_ca_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Idenifier of the SSL CA Cert"),
        ] = None,
        ssl_client_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the SSL Client Cert"),
        ] = None,
        ssl_client_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the SSL Client Key"),
        ] = None,
        sync_plan_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Plan numeric identifier"),
        ] = None,
        label: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Create a product


        :param organization_id: ID of the organization (required)
        :type organization_id: float
        :param name: Product name (required)
        :type name: str
        :param description: Product description
        :type description: str
        :param gpg_key_id: Identifier of the GPG key
        :type gpg_key_id: float
        :param ssl_ca_cert_id: Idenifier of the SSL CA Cert
        :type ssl_ca_cert_id: float
        :param ssl_client_cert_id: Identifier of the SSL Client Cert
        :type ssl_client_cert_id: float
        :param ssl_client_key_id: Identifier of the SSL Client Key
        :type ssl_client_key_id: float
        :param sync_plan_id: Plan numeric identifier
        :type sync_plan_id: float
        :param label:
        :type label: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_products_serialize(
            organization_id=organization_id,
            name=name,
            description=description,
            gpg_key_id=gpg_key_id,
            ssl_ca_cert_id=ssl_ca_cert_id,
            ssl_client_cert_id=ssl_client_cert_id,
            ssl_client_key_id=ssl_client_key_id,
            sync_plan_id=sync_plan_id,
            label=label,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def post_products_without_preload_content(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="ID of the organization")
        ],
        name: Annotated[StrictStr, Field(description="Product name")],
        description: Annotated[
            Optional[StrictStr], Field(description="Product description")
        ] = None,
        gpg_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the GPG key"),
        ] = None,
        ssl_ca_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Idenifier of the SSL CA Cert"),
        ] = None,
        ssl_client_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the SSL Client Cert"),
        ] = None,
        ssl_client_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the SSL Client Key"),
        ] = None,
        sync_plan_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Plan numeric identifier"),
        ] = None,
        label: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a product


        :param organization_id: ID of the organization (required)
        :type organization_id: float
        :param name: Product name (required)
        :type name: str
        :param description: Product description
        :type description: str
        :param gpg_key_id: Identifier of the GPG key
        :type gpg_key_id: float
        :param ssl_ca_cert_id: Idenifier of the SSL CA Cert
        :type ssl_ca_cert_id: float
        :param ssl_client_cert_id: Identifier of the SSL Client Cert
        :type ssl_client_cert_id: float
        :param ssl_client_key_id: Identifier of the SSL Client Key
        :type ssl_client_key_id: float
        :param sync_plan_id: Plan numeric identifier
        :type sync_plan_id: float
        :param label:
        :type label: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_products_serialize(
            organization_id=organization_id,
            name=name,
            description=description,
            gpg_key_id=gpg_key_id,
            ssl_ca_cert_id=ssl_ca_cert_id,
            ssl_client_cert_id=ssl_client_cert_id,
            ssl_client_key_id=ssl_client_key_id,
            sync_plan_id=sync_plan_id,
            label=label,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _post_products_serialize(
        self,
        organization_id,
        name,
        description,
        gpg_key_id,
        ssl_ca_cert_id,
        ssl_client_cert_id,
        ssl_client_key_id,
        sync_plan_id,
        label,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if organization_id is not None:
            _form_params.append(("organization_id", organization_id))
        if name is not None:
            _form_params.append(("name", name))
        if description is not None:
            _form_params.append(("description", description))
        if gpg_key_id is not None:
            _form_params.append(("gpg_key_id", gpg_key_id))
        if ssl_ca_cert_id is not None:
            _form_params.append(("ssl_ca_cert_id", ssl_ca_cert_id))
        if ssl_client_cert_id is not None:
            _form_params.append(("ssl_client_cert_id", ssl_client_cert_id))
        if ssl_client_key_id is not None:
            _form_params.append(("ssl_client_key_id", ssl_client_key_id))
        if sync_plan_id is not None:
            _form_params.append(("sync_plan_id", sync_plan_id))
        if label is not None:
            _form_params.append(("label", label))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/products",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def post_products_id_sync(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="product ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Sync all repositories for a product


        :param id: product ID (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_products_id_sync_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def post_products_id_sync_with_http_info(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="product ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Sync all repositories for a product


        :param id: product ID (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_products_id_sync_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def post_products_id_sync_without_preload_content(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="product ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Sync all repositories for a product


        :param id: product ID (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_products_id_sync_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _post_products_id_sync_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/products/{id}/sync",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def put_products_id(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="product numeric identifier"),
        ],
        description: Annotated[
            Optional[StrictStr], Field(description="Product description")
        ] = None,
        gpg_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the GPG key"),
        ] = None,
        ssl_ca_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Idenifier of the SSL CA Cert"),
        ] = None,
        ssl_client_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the SSL Client Cert"),
        ] = None,
        ssl_client_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the SSL Client Key"),
        ] = None,
        sync_plan_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Plan numeric identifier"),
        ] = None,
        name: Annotated[Optional[StrictStr], Field(description="Product name")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Updates a product


        :param id: product numeric identifier (required)
        :type id: float
        :param description: Product description
        :type description: str
        :param gpg_key_id: Identifier of the GPG key
        :type gpg_key_id: float
        :param ssl_ca_cert_id: Idenifier of the SSL CA Cert
        :type ssl_ca_cert_id: float
        :param ssl_client_cert_id: Identifier of the SSL Client Cert
        :type ssl_client_cert_id: float
        :param ssl_client_key_id: Identifier of the SSL Client Key
        :type ssl_client_key_id: float
        :param sync_plan_id: Plan numeric identifier
        :type sync_plan_id: float
        :param name: Product name
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_products_id_serialize(
            id=id,
            description=description,
            gpg_key_id=gpg_key_id,
            ssl_ca_cert_id=ssl_ca_cert_id,
            ssl_client_cert_id=ssl_client_cert_id,
            ssl_client_key_id=ssl_client_key_id,
            sync_plan_id=sync_plan_id,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def put_products_id_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="product numeric identifier"),
        ],
        description: Annotated[
            Optional[StrictStr], Field(description="Product description")
        ] = None,
        gpg_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the GPG key"),
        ] = None,
        ssl_ca_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Idenifier of the SSL CA Cert"),
        ] = None,
        ssl_client_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the SSL Client Cert"),
        ] = None,
        ssl_client_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the SSL Client Key"),
        ] = None,
        sync_plan_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Plan numeric identifier"),
        ] = None,
        name: Annotated[Optional[StrictStr], Field(description="Product name")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Updates a product


        :param id: product numeric identifier (required)
        :type id: float
        :param description: Product description
        :type description: str
        :param gpg_key_id: Identifier of the GPG key
        :type gpg_key_id: float
        :param ssl_ca_cert_id: Idenifier of the SSL CA Cert
        :type ssl_ca_cert_id: float
        :param ssl_client_cert_id: Identifier of the SSL Client Cert
        :type ssl_client_cert_id: float
        :param ssl_client_key_id: Identifier of the SSL Client Key
        :type ssl_client_key_id: float
        :param sync_plan_id: Plan numeric identifier
        :type sync_plan_id: float
        :param name: Product name
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_products_id_serialize(
            id=id,
            description=description,
            gpg_key_id=gpg_key_id,
            ssl_ca_cert_id=ssl_ca_cert_id,
            ssl_client_cert_id=ssl_client_cert_id,
            ssl_client_key_id=ssl_client_key_id,
            sync_plan_id=sync_plan_id,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def put_products_id_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="product numeric identifier"),
        ],
        description: Annotated[
            Optional[StrictStr], Field(description="Product description")
        ] = None,
        gpg_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the GPG key"),
        ] = None,
        ssl_ca_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Idenifier of the SSL CA Cert"),
        ] = None,
        ssl_client_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the SSL Client Cert"),
        ] = None,
        ssl_client_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Identifier of the SSL Client Key"),
        ] = None,
        sync_plan_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Plan numeric identifier"),
        ] = None,
        name: Annotated[Optional[StrictStr], Field(description="Product name")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Updates a product


        :param id: product numeric identifier (required)
        :type id: float
        :param description: Product description
        :type description: str
        :param gpg_key_id: Identifier of the GPG key
        :type gpg_key_id: float
        :param ssl_ca_cert_id: Idenifier of the SSL CA Cert
        :type ssl_ca_cert_id: float
        :param ssl_client_cert_id: Identifier of the SSL Client Cert
        :type ssl_client_cert_id: float
        :param ssl_client_key_id: Identifier of the SSL Client Key
        :type ssl_client_key_id: float
        :param sync_plan_id: Plan numeric identifier
        :type sync_plan_id: float
        :param name: Product name
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_products_id_serialize(
            id=id,
            description=description,
            gpg_key_id=gpg_key_id,
            ssl_ca_cert_id=ssl_ca_cert_id,
            ssl_client_cert_id=ssl_client_cert_id,
            ssl_client_key_id=ssl_client_key_id,
            sync_plan_id=sync_plan_id,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _put_products_id_serialize(
        self,
        id,
        description,
        gpg_key_id,
        ssl_ca_cert_id,
        ssl_client_cert_id,
        ssl_client_key_id,
        sync_plan_id,
        name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if description is not None:
            _form_params.append(("description", description))
        if gpg_key_id is not None:
            _form_params.append(("gpg_key_id", gpg_key_id))
        if ssl_ca_cert_id is not None:
            _form_params.append(("ssl_ca_cert_id", ssl_ca_cert_id))
        if ssl_client_cert_id is not None:
            _form_params.append(("ssl_client_cert_id", ssl_client_cert_id))
        if ssl_client_key_id is not None:
            _form_params.append(("ssl_client_key_id", ssl_client_key_id))
        if sync_plan_id is not None:
            _form_params.append(("sync_plan_id", sync_plan_id))
        if name is not None:
            _form_params.append(("name", name))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/products/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
