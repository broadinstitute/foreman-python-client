# coding: utf-8

"""
    Foreman (params in:formData)

     <p>Foreman API v2 is currently the default API version.</p> 

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from pydantic import Field
from typing_extensions import Annotated
from pydantic import (
    StrictBool,
    StrictBytes,
    StrictFloat,
    StrictInt,
    StrictStr,
    field_validator,
)

from typing import List, Optional, Union


from foreman.api_client import ApiClient
from foreman.api_response import ApiResponse
from foreman.rest import RESTResponseType


class RepositoriesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def delete_repositories_id(
        self,
        id: Union[StrictFloat, StrictInt],
        remove_from_content_view_versions: Annotated[
            Optional[StrictBool],
            Field(
                description="Force delete the repository by removing it from all content view versions"
            ),
        ] = None,
        delete_empty_repo_filters: Annotated[
            Optional[StrictBool],
            Field(
                description="Delete content view filters that have this repository as the last associated repository. Defaults to true. If false, such filters will now apply to all repositories in the content view."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Destroy a custom repository


        :param id: (required)
        :type id: float
        :param remove_from_content_view_versions: Force delete the repository by removing it from all content view versions
        :type remove_from_content_view_versions: bool
        :param delete_empty_repo_filters: Delete content view filters that have this repository as the last associated repository. Defaults to true. If false, such filters will now apply to all repositories in the content view.
        :type delete_empty_repo_filters: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_repositories_id_serialize(
            id=id,
            remove_from_content_view_versions=remove_from_content_view_versions,
            delete_empty_repo_filters=delete_empty_repo_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_repositories_id_with_http_info(
        self,
        id: Union[StrictFloat, StrictInt],
        remove_from_content_view_versions: Annotated[
            Optional[StrictBool],
            Field(
                description="Force delete the repository by removing it from all content view versions"
            ),
        ] = None,
        delete_empty_repo_filters: Annotated[
            Optional[StrictBool],
            Field(
                description="Delete content view filters that have this repository as the last associated repository. Defaults to true. If false, such filters will now apply to all repositories in the content view."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Destroy a custom repository


        :param id: (required)
        :type id: float
        :param remove_from_content_view_versions: Force delete the repository by removing it from all content view versions
        :type remove_from_content_view_versions: bool
        :param delete_empty_repo_filters: Delete content view filters that have this repository as the last associated repository. Defaults to true. If false, such filters will now apply to all repositories in the content view.
        :type delete_empty_repo_filters: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_repositories_id_serialize(
            id=id,
            remove_from_content_view_versions=remove_from_content_view_versions,
            delete_empty_repo_filters=delete_empty_repo_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_repositories_id_without_preload_content(
        self,
        id: Union[StrictFloat, StrictInt],
        remove_from_content_view_versions: Annotated[
            Optional[StrictBool],
            Field(
                description="Force delete the repository by removing it from all content view versions"
            ),
        ] = None,
        delete_empty_repo_filters: Annotated[
            Optional[StrictBool],
            Field(
                description="Delete content view filters that have this repository as the last associated repository. Defaults to true. If false, such filters will now apply to all repositories in the content view."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Destroy a custom repository


        :param id: (required)
        :type id: float
        :param remove_from_content_view_versions: Force delete the repository by removing it from all content view versions
        :type remove_from_content_view_versions: bool
        :param delete_empty_repo_filters: Delete content view filters that have this repository as the last associated repository. Defaults to true. If false, such filters will now apply to all repositories in the content view.
        :type delete_empty_repo_filters: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_repositories_id_serialize(
            id=id,
            remove_from_content_view_versions=remove_from_content_view_versions,
            delete_empty_repo_filters=delete_empty_repo_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_repositories_id_serialize(
        self,
        id,
        remove_from_content_view_versions,
        delete_empty_repo_filters,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if remove_from_content_view_versions is not None:
            _form_params.append(
                ("remove_from_content_view_versions", remove_from_content_view_versions)
            )
        if delete_empty_repo_filters is not None:
            _form_params.append(
                ("delete_empty_repo_filters", delete_empty_repo_filters)
            )
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/repositories/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_content_types(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Return the enabled content types


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_content_types_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_content_types_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Return the enabled content types


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_content_types_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_content_types_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return the enabled content types


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_content_types_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_content_types_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/content_types",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_content_views_id_repositories(
        self,
        id: Union[StrictFloat, StrictInt],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List of repositories for a content view


        :param id: (required)
        :type id: float
        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_content_views_id_repositories_serialize(
            id=id,
            organization_id=organization_id,
            product_id=product_id,
            environment_id=environment_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_content_views_id_repositories_with_http_info(
        self,
        id: Union[StrictFloat, StrictInt],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List of repositories for a content view


        :param id: (required)
        :type id: float
        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_content_views_id_repositories_serialize(
            id=id,
            organization_id=organization_id,
            product_id=product_id,
            environment_id=environment_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_content_views_id_repositories_without_preload_content(
        self,
        id: Union[StrictFloat, StrictInt],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of repositories for a content view


        :param id: (required)
        :type id: float
        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_content_views_id_repositories_serialize(
            id=id,
            organization_id=organization_id,
            product_id=product_id,
            environment_id=environment_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_content_views_id_repositories_serialize(
        self,
        id,
        organization_id,
        product_id,
        environment_id,
        content_view_id,
        content_view_version_id,
        deb_id,
        erratum_id,
        rpm_id,
        file_id,
        ansible_collection_id,
        library,
        archived,
        content_type,
        name,
        label,
        description,
        available_for,
        with_content,
        download_policy,
        username,
        search,
        page,
        per_page,
        order,
        full_result,
        sort_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        if product_id is not None:
            _query_params.append(("product_id", product_id))

        if environment_id is not None:
            _query_params.append(("environment_id", environment_id))

        if content_view_id is not None:
            _query_params.append(("content_view_id", content_view_id))

        if content_view_version_id is not None:
            _query_params.append(("content_view_version_id", content_view_version_id))

        if deb_id is not None:
            _query_params.append(("deb_id", deb_id))

        if erratum_id is not None:
            _query_params.append(("erratum_id", erratum_id))

        if rpm_id is not None:
            _query_params.append(("rpm_id", rpm_id))

        if file_id is not None:
            _query_params.append(("file_id", file_id))

        if ansible_collection_id is not None:
            _query_params.append(("ansible_collection_id", ansible_collection_id))

        if library is not None:
            _query_params.append(("library", library))

        if archived is not None:
            _query_params.append(("archived", archived))

        if content_type is not None:
            _query_params.append(("content_type", content_type))

        if name is not None:
            _query_params.append(("name", name))

        if label is not None:
            _query_params.append(("label", label))

        if description is not None:
            _query_params.append(("description", description))

        if available_for is not None:
            _query_params.append(("available_for", available_for))

        if with_content is not None:
            _query_params.append(("with_content", with_content))

        if download_policy is not None:
            _query_params.append(("download_policy", download_policy))

        if username is not None:
            _query_params.append(("username", username))

        if search is not None:
            _query_params.append(("search", search))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order is not None:
            _query_params.append(("order", order))

        if full_result is not None:
            _query_params.append(("full_result", full_result))

        if sort_by is not None:
            _query_params.append(("sort_by", sort_by))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/content_views/{id}/repositories",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_environments_environment_id_products_product_id_repositories(
        self,
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List of repositories belonging to a product in an environment


        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_environments_environment_id_products_product_id_repositories_serialize(
            product_id=product_id,
            environment_id=environment_id,
            organization_id=organization_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_environments_environment_id_products_product_id_repositories_with_http_info(
        self,
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List of repositories belonging to a product in an environment


        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_environments_environment_id_products_product_id_repositories_serialize(
            product_id=product_id,
            environment_id=environment_id,
            organization_id=organization_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_environments_environment_id_products_product_id_repositories_without_preload_content(
        self,
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of repositories belonging to a product in an environment


        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_environments_environment_id_products_product_id_repositories_serialize(
            product_id=product_id,
            environment_id=environment_id,
            organization_id=organization_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_environments_environment_id_products_product_id_repositories_serialize(
        self,
        product_id,
        environment_id,
        organization_id,
        content_view_id,
        content_view_version_id,
        deb_id,
        erratum_id,
        rpm_id,
        file_id,
        ansible_collection_id,
        library,
        archived,
        content_type,
        name,
        label,
        description,
        available_for,
        with_content,
        download_policy,
        username,
        search,
        page,
        per_page,
        order,
        full_result,
        sort_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if product_id is not None:
            _path_params["product_id"] = product_id
        if environment_id is not None:
            _path_params["environment_id"] = environment_id
        # process the query parameters
        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        if content_view_id is not None:
            _query_params.append(("content_view_id", content_view_id))

        if content_view_version_id is not None:
            _query_params.append(("content_view_version_id", content_view_version_id))

        if deb_id is not None:
            _query_params.append(("deb_id", deb_id))

        if erratum_id is not None:
            _query_params.append(("erratum_id", erratum_id))

        if rpm_id is not None:
            _query_params.append(("rpm_id", rpm_id))

        if file_id is not None:
            _query_params.append(("file_id", file_id))

        if ansible_collection_id is not None:
            _query_params.append(("ansible_collection_id", ansible_collection_id))

        if library is not None:
            _query_params.append(("library", library))

        if archived is not None:
            _query_params.append(("archived", archived))

        if content_type is not None:
            _query_params.append(("content_type", content_type))

        if name is not None:
            _query_params.append(("name", name))

        if label is not None:
            _query_params.append(("label", label))

        if description is not None:
            _query_params.append(("description", description))

        if available_for is not None:
            _query_params.append(("available_for", available_for))

        if with_content is not None:
            _query_params.append(("with_content", with_content))

        if download_policy is not None:
            _query_params.append(("download_policy", download_policy))

        if username is not None:
            _query_params.append(("username", username))

        if search is not None:
            _query_params.append(("search", search))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order is not None:
            _query_params.append(("order", order))

        if full_result is not None:
            _query_params.append(("full_result", full_result))

        if sort_by is not None:
            _query_params.append(("sort_by", sort_by))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/environments/{environment_id}/products/{product_id}/repositories",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_organizations_organization_id_environments_environment_id_repositories(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List repositories in the environment


        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_organizations_organization_id_environments_environment_id_repositories_serialize(
            organization_id=organization_id,
            environment_id=environment_id,
            product_id=product_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_organizations_organization_id_environments_environment_id_repositories_with_http_info(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List repositories in the environment


        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_organizations_organization_id_environments_environment_id_repositories_serialize(
            organization_id=organization_id,
            environment_id=environment_id,
            product_id=product_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_organizations_organization_id_environments_environment_id_repositories_without_preload_content(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List repositories in the environment


        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_organizations_organization_id_environments_environment_id_repositories_serialize(
            organization_id=organization_id,
            environment_id=environment_id,
            product_id=product_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_organizations_organization_id_environments_environment_id_repositories_serialize(
        self,
        organization_id,
        environment_id,
        product_id,
        content_view_id,
        content_view_version_id,
        deb_id,
        erratum_id,
        rpm_id,
        file_id,
        ansible_collection_id,
        library,
        archived,
        content_type,
        name,
        label,
        description,
        available_for,
        with_content,
        download_policy,
        username,
        search,
        page,
        per_page,
        order,
        full_result,
        sort_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if organization_id is not None:
            _path_params["organization_id"] = organization_id
        if environment_id is not None:
            _path_params["environment_id"] = environment_id
        # process the query parameters
        if product_id is not None:
            _query_params.append(("product_id", product_id))

        if content_view_id is not None:
            _query_params.append(("content_view_id", content_view_id))

        if content_view_version_id is not None:
            _query_params.append(("content_view_version_id", content_view_version_id))

        if deb_id is not None:
            _query_params.append(("deb_id", deb_id))

        if erratum_id is not None:
            _query_params.append(("erratum_id", erratum_id))

        if rpm_id is not None:
            _query_params.append(("rpm_id", rpm_id))

        if file_id is not None:
            _query_params.append(("file_id", file_id))

        if ansible_collection_id is not None:
            _query_params.append(("ansible_collection_id", ansible_collection_id))

        if library is not None:
            _query_params.append(("library", library))

        if archived is not None:
            _query_params.append(("archived", archived))

        if content_type is not None:
            _query_params.append(("content_type", content_type))

        if name is not None:
            _query_params.append(("name", name))

        if label is not None:
            _query_params.append(("label", label))

        if description is not None:
            _query_params.append(("description", description))

        if available_for is not None:
            _query_params.append(("available_for", available_for))

        if with_content is not None:
            _query_params.append(("with_content", with_content))

        if download_policy is not None:
            _query_params.append(("download_policy", download_policy))

        if username is not None:
            _query_params.append(("username", username))

        if search is not None:
            _query_params.append(("search", search))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order is not None:
            _query_params.append(("order", order))

        if full_result is not None:
            _query_params.append(("full_result", full_result))

        if sort_by is not None:
            _query_params.append(("sort_by", sort_by))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/organizations/{organization_id}/environments/{environment_id}/repositories",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_organizations_organization_id_repositories(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List of repositories in an organization


        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_organizations_organization_id_repositories_serialize(
            organization_id=organization_id,
            product_id=product_id,
            environment_id=environment_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_organizations_organization_id_repositories_with_http_info(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List of repositories in an organization


        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_organizations_organization_id_repositories_serialize(
            organization_id=organization_id,
            product_id=product_id,
            environment_id=environment_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_organizations_organization_id_repositories_without_preload_content(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of repositories in an organization


        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_organizations_organization_id_repositories_serialize(
            organization_id=organization_id,
            product_id=product_id,
            environment_id=environment_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_organizations_organization_id_repositories_serialize(
        self,
        organization_id,
        product_id,
        environment_id,
        content_view_id,
        content_view_version_id,
        deb_id,
        erratum_id,
        rpm_id,
        file_id,
        ansible_collection_id,
        library,
        archived,
        content_type,
        name,
        label,
        description,
        available_for,
        with_content,
        download_policy,
        username,
        search,
        page,
        per_page,
        order,
        full_result,
        sort_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if organization_id is not None:
            _path_params["organization_id"] = organization_id
        # process the query parameters
        if product_id is not None:
            _query_params.append(("product_id", product_id))

        if environment_id is not None:
            _query_params.append(("environment_id", environment_id))

        if content_view_id is not None:
            _query_params.append(("content_view_id", content_view_id))

        if content_view_version_id is not None:
            _query_params.append(("content_view_version_id", content_view_version_id))

        if deb_id is not None:
            _query_params.append(("deb_id", deb_id))

        if erratum_id is not None:
            _query_params.append(("erratum_id", erratum_id))

        if rpm_id is not None:
            _query_params.append(("rpm_id", rpm_id))

        if file_id is not None:
            _query_params.append(("file_id", file_id))

        if ansible_collection_id is not None:
            _query_params.append(("ansible_collection_id", ansible_collection_id))

        if library is not None:
            _query_params.append(("library", library))

        if archived is not None:
            _query_params.append(("archived", archived))

        if content_type is not None:
            _query_params.append(("content_type", content_type))

        if name is not None:
            _query_params.append(("name", name))

        if label is not None:
            _query_params.append(("label", label))

        if description is not None:
            _query_params.append(("description", description))

        if available_for is not None:
            _query_params.append(("available_for", available_for))

        if with_content is not None:
            _query_params.append(("with_content", with_content))

        if download_policy is not None:
            _query_params.append(("download_policy", download_policy))

        if username is not None:
            _query_params.append(("username", username))

        if search is not None:
            _query_params.append(("search", search))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order is not None:
            _query_params.append(("order", order))

        if full_result is not None:
            _query_params.append(("full_result", full_result))

        if sort_by is not None:
            _query_params.append(("sort_by", sort_by))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/organizations/{organization_id}/repositories",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_products_product_id_repositories(
        self,
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List of repositories for a product


        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_products_product_id_repositories_serialize(
            product_id=product_id,
            organization_id=organization_id,
            environment_id=environment_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_products_product_id_repositories_with_http_info(
        self,
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List of repositories for a product


        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_products_product_id_repositories_serialize(
            product_id=product_id,
            organization_id=organization_id,
            environment_id=environment_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_products_product_id_repositories_without_preload_content(
        self,
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of repositories for a product


        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_products_product_id_repositories_serialize(
            product_id=product_id,
            organization_id=organization_id,
            environment_id=environment_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_products_product_id_repositories_serialize(
        self,
        product_id,
        organization_id,
        environment_id,
        content_view_id,
        content_view_version_id,
        deb_id,
        erratum_id,
        rpm_id,
        file_id,
        ansible_collection_id,
        library,
        archived,
        content_type,
        name,
        label,
        description,
        available_for,
        with_content,
        download_policy,
        username,
        search,
        page,
        per_page,
        order,
        full_result,
        sort_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if product_id is not None:
            _path_params["product_id"] = product_id
        # process the query parameters
        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        if environment_id is not None:
            _query_params.append(("environment_id", environment_id))

        if content_view_id is not None:
            _query_params.append(("content_view_id", content_view_id))

        if content_view_version_id is not None:
            _query_params.append(("content_view_version_id", content_view_version_id))

        if deb_id is not None:
            _query_params.append(("deb_id", deb_id))

        if erratum_id is not None:
            _query_params.append(("erratum_id", erratum_id))

        if rpm_id is not None:
            _query_params.append(("rpm_id", rpm_id))

        if file_id is not None:
            _query_params.append(("file_id", file_id))

        if ansible_collection_id is not None:
            _query_params.append(("ansible_collection_id", ansible_collection_id))

        if library is not None:
            _query_params.append(("library", library))

        if archived is not None:
            _query_params.append(("archived", archived))

        if content_type is not None:
            _query_params.append(("content_type", content_type))

        if name is not None:
            _query_params.append(("name", name))

        if label is not None:
            _query_params.append(("label", label))

        if description is not None:
            _query_params.append(("description", description))

        if available_for is not None:
            _query_params.append(("available_for", available_for))

        if with_content is not None:
            _query_params.append(("with_content", with_content))

        if download_policy is not None:
            _query_params.append(("download_policy", download_policy))

        if username is not None:
            _query_params.append(("username", username))

        if search is not None:
            _query_params.append(("search", search))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order is not None:
            _query_params.append(("order", order))

        if full_result is not None:
            _query_params.append(("full_result", full_result))

        if sort_by is not None:
            _query_params.append(("sort_by", sort_by))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/products/{product_id}/repositories",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_repositories(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List of enabled repositories


        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_serialize(
            organization_id=organization_id,
            product_id=product_id,
            environment_id=environment_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_repositories_with_http_info(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List of enabled repositories


        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_serialize(
            organization_id=organization_id,
            product_id=product_id,
            environment_id=environment_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_repositories_without_preload_content(
        self,
        organization_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an organization to show repositories in"),
        ],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of a product to show repositories of"),
        ],
        environment_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="ID of an environment to show repositories in"),
        ],
        content_view_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view to show repositories in"),
        ] = None,
        content_view_version_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a content view version to show repositories in"),
        ] = None,
        deb_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a deb package to find repositories that contain the deb"
            ),
        ] = None,
        erratum_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an erratum to find repositories that contain the erratum"
            ),
        ] = None,
        rpm_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a rpm package to find repositories that contain the rpm"
            ),
        ] = None,
        file_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of a file to find repositories that contain the file"
            ),
        ] = None,
        ansible_collection_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Id of an ansible collection to find repositories that contain the ansible collection"
            ),
        ] = None,
        library: Annotated[
            Optional[StrictBool],
            Field(
                description="show repositories in Library and the default content view"
            ),
        ] = None,
        archived: Annotated[
            Optional[StrictBool], Field(description="show archived repositories")
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ] = None,
        name: Annotated[
            Optional[StrictStr], Field(description="name of the repository")
        ] = None,
        label: Annotated[
            Optional[StrictStr], Field(description="label of the repository")
        ] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        available_for: Annotated[
            Optional[StrictStr],
            Field(
                description="interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported."
            ),
        ] = None,
        with_content: Annotated[
            Optional[StrictStr],
            Field(
                description='Filter repositories by content unit type (erratum, docker_tag, etc.). Check the "Indexed?" types here: /katello/api/repositories/repository_types'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(description="limit to only repositories with this download policy"),
        ] = None,
        username: Annotated[
            Optional[StrictStr],
            Field(
                description="only show the repositories readable by this user with this username"
            ),
        ] = None,
        search: Annotated[
            Optional[StrictStr], Field(description="Search string")
        ] = None,
        page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Page number, starting at 1"),
        ] = None,
        per_page: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Number of results per page to return"),
        ] = None,
        order: Annotated[
            Optional[StrictStr],
            Field(description="Sort field and order, eg. 'id DESC'"),
        ] = None,
        full_result: Annotated[
            Optional[StrictBool],
            Field(description="Whether or not to show all results"),
        ] = None,
        sort_by: Annotated[
            Optional[StrictStr], Field(description="Field to sort the results on")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="How to order the sorted results (e.g. ASC for ascending)"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of enabled repositories


        :param organization_id: ID of an organization to show repositories in (required)
        :type organization_id: float
        :param product_id: ID of a product to show repositories of (required)
        :type product_id: float
        :param environment_id: ID of an environment to show repositories in (required)
        :type environment_id: float
        :param content_view_id: ID of a content view to show repositories in
        :type content_view_id: float
        :param content_view_version_id: ID of a content view version to show repositories in
        :type content_view_version_id: float
        :param deb_id: Id of a deb package to find repositories that contain the deb
        :type deb_id: str
        :param erratum_id: Id of an erratum to find repositories that contain the erratum
        :type erratum_id: str
        :param rpm_id: Id of a rpm package to find repositories that contain the rpm
        :type rpm_id: str
        :param file_id: Id of a file to find repositories that contain the file
        :type file_id: str
        :param ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :type ansible_collection_id: str
        :param library: show repositories in Library and the default content view
        :type library: bool
        :param archived: show archived repositories
        :type archived: bool
        :param content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :type content_type: str
        :param name: name of the repository
        :type name: str
        :param label: label of the repository
        :type label: str
        :param description: description of the repository
        :type description: str
        :param available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :type available_for: str
        :param with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :type with_content: str
        :param download_policy: limit to only repositories with this download policy
        :type download_policy: str
        :param username: only show the repositories readable by this user with this username
        :type username: str
        :param search: Search string
        :type search: str
        :param page: Page number, starting at 1
        :type page: float
        :param per_page: Number of results per page to return
        :type per_page: float
        :param order: Sort field and order, eg. 'id DESC'
        :type order: str
        :param full_result: Whether or not to show all results
        :type full_result: bool
        :param sort_by: Field to sort the results on
        :type sort_by: str
        :param sort_order: How to order the sorted results (e.g. ASC for ascending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_serialize(
            organization_id=organization_id,
            product_id=product_id,
            environment_id=environment_id,
            content_view_id=content_view_id,
            content_view_version_id=content_view_version_id,
            deb_id=deb_id,
            erratum_id=erratum_id,
            rpm_id=rpm_id,
            file_id=file_id,
            ansible_collection_id=ansible_collection_id,
            library=library,
            archived=archived,
            content_type=content_type,
            name=name,
            label=label,
            description=description,
            available_for=available_for,
            with_content=with_content,
            download_policy=download_policy,
            username=username,
            search=search,
            page=page,
            per_page=per_page,
            order=order,
            full_result=full_result,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_repositories_serialize(
        self,
        organization_id,
        product_id,
        environment_id,
        content_view_id,
        content_view_version_id,
        deb_id,
        erratum_id,
        rpm_id,
        file_id,
        ansible_collection_id,
        library,
        archived,
        content_type,
        name,
        label,
        description,
        available_for,
        with_content,
        download_policy,
        username,
        search,
        page,
        per_page,
        order,
        full_result,
        sort_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        if product_id is not None:
            _query_params.append(("product_id", product_id))

        if environment_id is not None:
            _query_params.append(("environment_id", environment_id))

        if content_view_id is not None:
            _query_params.append(("content_view_id", content_view_id))

        if content_view_version_id is not None:
            _query_params.append(("content_view_version_id", content_view_version_id))

        if deb_id is not None:
            _query_params.append(("deb_id", deb_id))

        if erratum_id is not None:
            _query_params.append(("erratum_id", erratum_id))

        if rpm_id is not None:
            _query_params.append(("rpm_id", rpm_id))

        if file_id is not None:
            _query_params.append(("file_id", file_id))

        if ansible_collection_id is not None:
            _query_params.append(("ansible_collection_id", ansible_collection_id))

        if library is not None:
            _query_params.append(("library", library))

        if archived is not None:
            _query_params.append(("archived", archived))

        if content_type is not None:
            _query_params.append(("content_type", content_type))

        if name is not None:
            _query_params.append(("name", name))

        if label is not None:
            _query_params.append(("label", label))

        if description is not None:
            _query_params.append(("description", description))

        if available_for is not None:
            _query_params.append(("available_for", available_for))

        if with_content is not None:
            _query_params.append(("with_content", with_content))

        if download_policy is not None:
            _query_params.append(("download_policy", download_policy))

        if username is not None:
            _query_params.append(("username", username))

        if search is not None:
            _query_params.append(("search", search))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if order is not None:
            _query_params.append(("order", order))

        if full_result is not None:
            _query_params.append(("full_result", full_result))

        if sort_by is not None:
            _query_params.append(("sort_by", sort_by))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/repositories",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_repositories_compare(
        self,
        content_view_version_ids: Annotated[
            Optional[List[StrictStr]],
            Field(description="content view versions to compare"),
        ] = None,
        repository_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Library repository id to restrict comparisons to"),
        ] = None,
        restrict_comparison: Annotated[
            Optional[StrictStr],
            Field(description="Return same, different or all results"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """List :resource


        :param content_view_version_ids: content view versions to compare
        :type content_view_version_ids: List[str]
        :param repository_id: Library repository id to restrict comparisons to
        :type repository_id: float
        :param restrict_comparison: Return same, different or all results
        :type restrict_comparison: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_compare_serialize(
            content_view_version_ids=content_view_version_ids,
            repository_id=repository_id,
            restrict_comparison=restrict_comparison,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_repositories_compare_with_http_info(
        self,
        content_view_version_ids: Annotated[
            Optional[List[StrictStr]],
            Field(description="content view versions to compare"),
        ] = None,
        repository_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Library repository id to restrict comparisons to"),
        ] = None,
        restrict_comparison: Annotated[
            Optional[StrictStr],
            Field(description="Return same, different or all results"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """List :resource


        :param content_view_version_ids: content view versions to compare
        :type content_view_version_ids: List[str]
        :param repository_id: Library repository id to restrict comparisons to
        :type repository_id: float
        :param restrict_comparison: Return same, different or all results
        :type restrict_comparison: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_compare_serialize(
            content_view_version_ids=content_view_version_ids,
            repository_id=repository_id,
            restrict_comparison=restrict_comparison,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_repositories_compare_without_preload_content(
        self,
        content_view_version_ids: Annotated[
            Optional[List[StrictStr]],
            Field(description="content view versions to compare"),
        ] = None,
        repository_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Library repository id to restrict comparisons to"),
        ] = None,
        restrict_comparison: Annotated[
            Optional[StrictStr],
            Field(description="Return same, different or all results"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List :resource


        :param content_view_version_ids: content view versions to compare
        :type content_view_version_ids: List[str]
        :param repository_id: Library repository id to restrict comparisons to
        :type repository_id: float
        :param restrict_comparison: Return same, different or all results
        :type restrict_comparison: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_compare_serialize(
            content_view_version_ids=content_view_version_ids,
            repository_id=repository_id,
            restrict_comparison=restrict_comparison,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_repositories_compare_serialize(
        self,
        content_view_version_ids,
        repository_id,
        restrict_comparison,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {
            "content_view_version_ids": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if content_view_version_ids is not None:
            _query_params.append(("content_view_version_ids", content_view_version_ids))

        if repository_id is not None:
            _query_params.append(("repository_id", repository_id))

        if restrict_comparison is not None:
            _query_params.append(("restrict_comparison", restrict_comparison))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/repositories/compare",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_repositories_id(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Organization ID"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Show a repository


        :param id: repository ID (required)
        :type id: float
        :param organization_id: Organization ID
        :type organization_id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_id_serialize(
            id=id,
            organization_id=organization_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_repositories_id_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Organization ID"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Show a repository


        :param id: repository ID (required)
        :type id: float
        :param organization_id: Organization ID
        :type organization_id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_id_serialize(
            id=id,
            organization_id=organization_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_repositories_id_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        organization_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Organization ID"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Show a repository


        :param id: repository ID (required)
        :type id: float
        :param organization_id: Organization ID
        :type organization_id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_id_serialize(
            id=id,
            organization_id=organization_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_repositories_id_serialize(
        self,
        id,
        organization_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        if organization_id is not None:
            _query_params.append(("organization_id", organization_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/repositories/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_repositories_id_gpg_key_content(
        self,
        id: Union[StrictFloat, StrictInt],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Return the content of a repo gpg key, used directly by yum


        :param id: (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_id_gpg_key_content_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_repositories_id_gpg_key_content_with_http_info(
        self,
        id: Union[StrictFloat, StrictInt],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Return the content of a repo gpg key, used directly by yum


        :param id: (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_id_gpg_key_content_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_repositories_id_gpg_key_content_without_preload_content(
        self,
        id: Union[StrictFloat, StrictInt],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return the content of a repo gpg key, used directly by yum


        :param id: (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_id_gpg_key_content_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_repositories_id_gpg_key_content_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/repositories/{id}/gpg_key_content",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_repositories_repository_types(
        self,
        creatable: Annotated[
            Optional[StrictBool],
            Field(
                description="When set to 'True' repository types that are creatable will be returned"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Show the available repository types


        :param creatable: When set to 'True' repository types that are creatable will be returned
        :type creatable: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_repository_types_serialize(
            creatable=creatable,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_repositories_repository_types_with_http_info(
        self,
        creatable: Annotated[
            Optional[StrictBool],
            Field(
                description="When set to 'True' repository types that are creatable will be returned"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Show the available repository types


        :param creatable: When set to 'True' repository types that are creatable will be returned
        :type creatable: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_repository_types_serialize(
            creatable=creatable,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_repositories_repository_types_without_preload_content(
        self,
        creatable: Annotated[
            Optional[StrictBool],
            Field(
                description="When set to 'True' repository types that are creatable will be returned"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Show the available repository types


        :param creatable: When set to 'True' repository types that are creatable will be returned
        :type creatable: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_repositories_repository_types_serialize(
            creatable=creatable,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_repositories_repository_types_serialize(
        self,
        creatable,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if creatable is not None:
            _query_params.append(("creatable", creatable))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/repositories/repository_types",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def post_repositories(
        self,
        name: Annotated[StrictStr, Field(description="Name of the repository")],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Product the repository belongs to"),
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                description="Type of repository. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ],
        description: Annotated[
            Optional[StrictStr], Field(description="Description of the repository")
        ] = None,
        label: Optional[StrictStr] = None,
        url: Annotated[
            Optional[StrictStr], Field(description="repository source url")
        ] = None,
        os_versions: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9"
            ),
        ] = None,
        gpg_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="id of the gpg key that will be assigned to the new repository"
            ),
        ] = None,
        ssl_ca_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL CA Cert"
            ),
        ] = None,
        ssl_client_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL Client Cert"
            ),
        ] = None,
        ssl_client_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL Client Key"
            ),
        ] = None,
        unprotected: Annotated[
            Optional[StrictBool],
            Field(description="true if this repository can be published via HTTP"),
        ] = None,
        checksum_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Checksum of the repository, currently 'sha1' & 'sha256' are supported"
            ),
        ] = None,
        docker_upstream_name: Annotated[
            Optional[StrictStr],
            Field(description="Name of the upstream docker repository"),
        ] = None,
        include_tags: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Comma-separated list of tags to sync for a container image repository"
            ),
        ] = None,
        exclude_tags: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \\"-source\\"'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(
                description="download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')"
            ),
        ] = None,
        download_concurrency: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10"
            ),
        ] = None,
        mirroring_policy: Annotated[
            Optional[StrictStr],
            Field(
                description="Policy to set for mirroring content.  Must be one of additive."
            ),
        ] = None,
        verify_ssl_on_sync: Annotated[
            Optional[StrictBool],
            Field(
                description="if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA"
            ),
        ] = None,
        upstream_username: Annotated[
            Optional[StrictStr],
            Field(
                description="Username of the upstream repository user used for authentication"
            ),
        ] = None,
        upstream_password: Annotated[
            Optional[StrictStr],
            Field(
                description="Password of the upstream repository user used for authentication"
            ),
        ] = None,
        upstream_authentication_token: Annotated[
            Optional[StrictStr],
            Field(description="Password of the upstream authentication token."),
        ] = None,
        deb_releases: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of releases to be synced from deb-archive"
            ),
        ] = None,
        deb_components: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of repo components to be synced from deb-archive"
            ),
        ] = None,
        deb_architectures: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of architectures to be synced from deb-archive"
            ),
        ] = None,
        ignorable_content: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo"
            ),
        ] = None,
        ansible_collection_requirements: Annotated[
            Optional[StrictStr],
            Field(description="Contents of requirement yaml file to sync from URL"),
        ] = None,
        ansible_collection_auth_url: Annotated[
            Optional[StrictStr],
            Field(
                description="The URL to receive a session token from, e.g. used with Automation Hub."
            ),
        ] = None,
        ansible_collection_auth_token: Annotated[
            Optional[StrictStr],
            Field(description="The token key to use for authentication."),
        ] = None,
        http_proxy_policy: Annotated[
            Optional[StrictStr],
            Field(description="policies for HTTP proxy for content sync"),
        ] = None,
        http_proxy_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a HTTP Proxy"),
        ] = None,
        arch: Annotated[
            Optional[StrictStr],
            Field(description="Architecture of content in the repository"),
        ] = None,
        retain_package_versions_count: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="The maximum number of versions of each package to keep."
            ),
        ] = None,
        metadata_expire: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Time to expire yum metadata in seconds. Only relevant for custom yum repositories."
            ),
        ] = None,
        excludes: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0."
            ),
        ] = None,
        includes: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package."
            ),
        ] = None,
        package_types: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Create a custom repository


        :param name: Name of the repository (required)
        :type name: str
        :param product_id: Product the repository belongs to (required)
        :type product_id: float
        :param content_type: Type of repository. Available types endpoint: /katello/api/repositories/repository_types (required)
        :type content_type: str
        :param description: Description of the repository
        :type description: str
        :param label:
        :type label: str
        :param url: repository source url
        :type url: str
        :param os_versions: Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9
        :type os_versions: List[str]
        :param gpg_key_id: id of the gpg key that will be assigned to the new repository
        :type gpg_key_id: float
        :param ssl_ca_cert_id: Identifier of the content credential containing the SSL CA Cert
        :type ssl_ca_cert_id: float
        :param ssl_client_cert_id: Identifier of the content credential containing the SSL Client Cert
        :type ssl_client_cert_id: float
        :param ssl_client_key_id: Identifier of the content credential containing the SSL Client Key
        :type ssl_client_key_id: float
        :param unprotected: true if this repository can be published via HTTP
        :type unprotected: bool
        :param checksum_type: Checksum of the repository, currently 'sha1' & 'sha256' are supported
        :type checksum_type: str
        :param docker_upstream_name: Name of the upstream docker repository
        :type docker_upstream_name: str
        :param include_tags: Comma-separated list of tags to sync for a container image repository
        :type include_tags: List[str]
        :param exclude_tags: Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \\\"-source\\\"
        :type exclude_tags: List[str]
        :param download_policy: download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')
        :type download_policy: str
        :param download_concurrency: Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10
        :type download_concurrency: float
        :param mirroring_policy: Policy to set for mirroring content.  Must be one of additive.
        :type mirroring_policy: str
        :param verify_ssl_on_sync: if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA
        :type verify_ssl_on_sync: bool
        :param upstream_username: Username of the upstream repository user used for authentication
        :type upstream_username: str
        :param upstream_password: Password of the upstream repository user used for authentication
        :type upstream_password: str
        :param upstream_authentication_token: Password of the upstream authentication token.
        :type upstream_authentication_token: str
        :param deb_releases: whitespace-separated list of releases to be synced from deb-archive
        :type deb_releases: str
        :param deb_components: whitespace-separated list of repo components to be synced from deb-archive
        :type deb_components: str
        :param deb_architectures: whitespace-separated list of architectures to be synced from deb-archive
        :type deb_architectures: str
        :param ignorable_content: List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo
        :type ignorable_content: List[str]
        :param ansible_collection_requirements: Contents of requirement yaml file to sync from URL
        :type ansible_collection_requirements: str
        :param ansible_collection_auth_url: The URL to receive a session token from, e.g. used with Automation Hub.
        :type ansible_collection_auth_url: str
        :param ansible_collection_auth_token: The token key to use for authentication.
        :type ansible_collection_auth_token: str
        :param http_proxy_policy: policies for HTTP proxy for content sync
        :type http_proxy_policy: str
        :param http_proxy_id: ID of a HTTP Proxy
        :type http_proxy_id: float
        :param arch: Architecture of content in the repository
        :type arch: str
        :param retain_package_versions_count: The maximum number of versions of each package to keep.
        :type retain_package_versions_count: float
        :param metadata_expire: Time to expire yum metadata in seconds. Only relevant for custom yum repositories.
        :type metadata_expire: float
        :param excludes: Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0.
        :type excludes: List[str]
        :param includes: Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package.
        :type includes: List[str]
        :param package_types: Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist.
        :type package_types: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_serialize(
            name=name,
            product_id=product_id,
            content_type=content_type,
            description=description,
            label=label,
            url=url,
            os_versions=os_versions,
            gpg_key_id=gpg_key_id,
            ssl_ca_cert_id=ssl_ca_cert_id,
            ssl_client_cert_id=ssl_client_cert_id,
            ssl_client_key_id=ssl_client_key_id,
            unprotected=unprotected,
            checksum_type=checksum_type,
            docker_upstream_name=docker_upstream_name,
            include_tags=include_tags,
            exclude_tags=exclude_tags,
            download_policy=download_policy,
            download_concurrency=download_concurrency,
            mirroring_policy=mirroring_policy,
            verify_ssl_on_sync=verify_ssl_on_sync,
            upstream_username=upstream_username,
            upstream_password=upstream_password,
            upstream_authentication_token=upstream_authentication_token,
            deb_releases=deb_releases,
            deb_components=deb_components,
            deb_architectures=deb_architectures,
            ignorable_content=ignorable_content,
            ansible_collection_requirements=ansible_collection_requirements,
            ansible_collection_auth_url=ansible_collection_auth_url,
            ansible_collection_auth_token=ansible_collection_auth_token,
            http_proxy_policy=http_proxy_policy,
            http_proxy_id=http_proxy_id,
            arch=arch,
            retain_package_versions_count=retain_package_versions_count,
            metadata_expire=metadata_expire,
            excludes=excludes,
            includes=includes,
            package_types=package_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def post_repositories_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="Name of the repository")],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Product the repository belongs to"),
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                description="Type of repository. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ],
        description: Annotated[
            Optional[StrictStr], Field(description="Description of the repository")
        ] = None,
        label: Optional[StrictStr] = None,
        url: Annotated[
            Optional[StrictStr], Field(description="repository source url")
        ] = None,
        os_versions: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9"
            ),
        ] = None,
        gpg_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="id of the gpg key that will be assigned to the new repository"
            ),
        ] = None,
        ssl_ca_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL CA Cert"
            ),
        ] = None,
        ssl_client_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL Client Cert"
            ),
        ] = None,
        ssl_client_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL Client Key"
            ),
        ] = None,
        unprotected: Annotated[
            Optional[StrictBool],
            Field(description="true if this repository can be published via HTTP"),
        ] = None,
        checksum_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Checksum of the repository, currently 'sha1' & 'sha256' are supported"
            ),
        ] = None,
        docker_upstream_name: Annotated[
            Optional[StrictStr],
            Field(description="Name of the upstream docker repository"),
        ] = None,
        include_tags: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Comma-separated list of tags to sync for a container image repository"
            ),
        ] = None,
        exclude_tags: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \\"-source\\"'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(
                description="download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')"
            ),
        ] = None,
        download_concurrency: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10"
            ),
        ] = None,
        mirroring_policy: Annotated[
            Optional[StrictStr],
            Field(
                description="Policy to set for mirroring content.  Must be one of additive."
            ),
        ] = None,
        verify_ssl_on_sync: Annotated[
            Optional[StrictBool],
            Field(
                description="if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA"
            ),
        ] = None,
        upstream_username: Annotated[
            Optional[StrictStr],
            Field(
                description="Username of the upstream repository user used for authentication"
            ),
        ] = None,
        upstream_password: Annotated[
            Optional[StrictStr],
            Field(
                description="Password of the upstream repository user used for authentication"
            ),
        ] = None,
        upstream_authentication_token: Annotated[
            Optional[StrictStr],
            Field(description="Password of the upstream authentication token."),
        ] = None,
        deb_releases: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of releases to be synced from deb-archive"
            ),
        ] = None,
        deb_components: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of repo components to be synced from deb-archive"
            ),
        ] = None,
        deb_architectures: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of architectures to be synced from deb-archive"
            ),
        ] = None,
        ignorable_content: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo"
            ),
        ] = None,
        ansible_collection_requirements: Annotated[
            Optional[StrictStr],
            Field(description="Contents of requirement yaml file to sync from URL"),
        ] = None,
        ansible_collection_auth_url: Annotated[
            Optional[StrictStr],
            Field(
                description="The URL to receive a session token from, e.g. used with Automation Hub."
            ),
        ] = None,
        ansible_collection_auth_token: Annotated[
            Optional[StrictStr],
            Field(description="The token key to use for authentication."),
        ] = None,
        http_proxy_policy: Annotated[
            Optional[StrictStr],
            Field(description="policies for HTTP proxy for content sync"),
        ] = None,
        http_proxy_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a HTTP Proxy"),
        ] = None,
        arch: Annotated[
            Optional[StrictStr],
            Field(description="Architecture of content in the repository"),
        ] = None,
        retain_package_versions_count: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="The maximum number of versions of each package to keep."
            ),
        ] = None,
        metadata_expire: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Time to expire yum metadata in seconds. Only relevant for custom yum repositories."
            ),
        ] = None,
        excludes: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0."
            ),
        ] = None,
        includes: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package."
            ),
        ] = None,
        package_types: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Create a custom repository


        :param name: Name of the repository (required)
        :type name: str
        :param product_id: Product the repository belongs to (required)
        :type product_id: float
        :param content_type: Type of repository. Available types endpoint: /katello/api/repositories/repository_types (required)
        :type content_type: str
        :param description: Description of the repository
        :type description: str
        :param label:
        :type label: str
        :param url: repository source url
        :type url: str
        :param os_versions: Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9
        :type os_versions: List[str]
        :param gpg_key_id: id of the gpg key that will be assigned to the new repository
        :type gpg_key_id: float
        :param ssl_ca_cert_id: Identifier of the content credential containing the SSL CA Cert
        :type ssl_ca_cert_id: float
        :param ssl_client_cert_id: Identifier of the content credential containing the SSL Client Cert
        :type ssl_client_cert_id: float
        :param ssl_client_key_id: Identifier of the content credential containing the SSL Client Key
        :type ssl_client_key_id: float
        :param unprotected: true if this repository can be published via HTTP
        :type unprotected: bool
        :param checksum_type: Checksum of the repository, currently 'sha1' & 'sha256' are supported
        :type checksum_type: str
        :param docker_upstream_name: Name of the upstream docker repository
        :type docker_upstream_name: str
        :param include_tags: Comma-separated list of tags to sync for a container image repository
        :type include_tags: List[str]
        :param exclude_tags: Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \\\"-source\\\"
        :type exclude_tags: List[str]
        :param download_policy: download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')
        :type download_policy: str
        :param download_concurrency: Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10
        :type download_concurrency: float
        :param mirroring_policy: Policy to set for mirroring content.  Must be one of additive.
        :type mirroring_policy: str
        :param verify_ssl_on_sync: if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA
        :type verify_ssl_on_sync: bool
        :param upstream_username: Username of the upstream repository user used for authentication
        :type upstream_username: str
        :param upstream_password: Password of the upstream repository user used for authentication
        :type upstream_password: str
        :param upstream_authentication_token: Password of the upstream authentication token.
        :type upstream_authentication_token: str
        :param deb_releases: whitespace-separated list of releases to be synced from deb-archive
        :type deb_releases: str
        :param deb_components: whitespace-separated list of repo components to be synced from deb-archive
        :type deb_components: str
        :param deb_architectures: whitespace-separated list of architectures to be synced from deb-archive
        :type deb_architectures: str
        :param ignorable_content: List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo
        :type ignorable_content: List[str]
        :param ansible_collection_requirements: Contents of requirement yaml file to sync from URL
        :type ansible_collection_requirements: str
        :param ansible_collection_auth_url: The URL to receive a session token from, e.g. used with Automation Hub.
        :type ansible_collection_auth_url: str
        :param ansible_collection_auth_token: The token key to use for authentication.
        :type ansible_collection_auth_token: str
        :param http_proxy_policy: policies for HTTP proxy for content sync
        :type http_proxy_policy: str
        :param http_proxy_id: ID of a HTTP Proxy
        :type http_proxy_id: float
        :param arch: Architecture of content in the repository
        :type arch: str
        :param retain_package_versions_count: The maximum number of versions of each package to keep.
        :type retain_package_versions_count: float
        :param metadata_expire: Time to expire yum metadata in seconds. Only relevant for custom yum repositories.
        :type metadata_expire: float
        :param excludes: Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0.
        :type excludes: List[str]
        :param includes: Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package.
        :type includes: List[str]
        :param package_types: Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist.
        :type package_types: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_serialize(
            name=name,
            product_id=product_id,
            content_type=content_type,
            description=description,
            label=label,
            url=url,
            os_versions=os_versions,
            gpg_key_id=gpg_key_id,
            ssl_ca_cert_id=ssl_ca_cert_id,
            ssl_client_cert_id=ssl_client_cert_id,
            ssl_client_key_id=ssl_client_key_id,
            unprotected=unprotected,
            checksum_type=checksum_type,
            docker_upstream_name=docker_upstream_name,
            include_tags=include_tags,
            exclude_tags=exclude_tags,
            download_policy=download_policy,
            download_concurrency=download_concurrency,
            mirroring_policy=mirroring_policy,
            verify_ssl_on_sync=verify_ssl_on_sync,
            upstream_username=upstream_username,
            upstream_password=upstream_password,
            upstream_authentication_token=upstream_authentication_token,
            deb_releases=deb_releases,
            deb_components=deb_components,
            deb_architectures=deb_architectures,
            ignorable_content=ignorable_content,
            ansible_collection_requirements=ansible_collection_requirements,
            ansible_collection_auth_url=ansible_collection_auth_url,
            ansible_collection_auth_token=ansible_collection_auth_token,
            http_proxy_policy=http_proxy_policy,
            http_proxy_id=http_proxy_id,
            arch=arch,
            retain_package_versions_count=retain_package_versions_count,
            metadata_expire=metadata_expire,
            excludes=excludes,
            includes=includes,
            package_types=package_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def post_repositories_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="Name of the repository")],
        product_id: Annotated[
            Union[StrictFloat, StrictInt],
            Field(description="Product the repository belongs to"),
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                description="Type of repository. Available types endpoint: /katello/api/repositories/repository_types"
            ),
        ],
        description: Annotated[
            Optional[StrictStr], Field(description="Description of the repository")
        ] = None,
        label: Optional[StrictStr] = None,
        url: Annotated[
            Optional[StrictStr], Field(description="repository source url")
        ] = None,
        os_versions: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9"
            ),
        ] = None,
        gpg_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="id of the gpg key that will be assigned to the new repository"
            ),
        ] = None,
        ssl_ca_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL CA Cert"
            ),
        ] = None,
        ssl_client_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL Client Cert"
            ),
        ] = None,
        ssl_client_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL Client Key"
            ),
        ] = None,
        unprotected: Annotated[
            Optional[StrictBool],
            Field(description="true if this repository can be published via HTTP"),
        ] = None,
        checksum_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Checksum of the repository, currently 'sha1' & 'sha256' are supported"
            ),
        ] = None,
        docker_upstream_name: Annotated[
            Optional[StrictStr],
            Field(description="Name of the upstream docker repository"),
        ] = None,
        include_tags: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Comma-separated list of tags to sync for a container image repository"
            ),
        ] = None,
        exclude_tags: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \\"-source\\"'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(
                description="download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')"
            ),
        ] = None,
        download_concurrency: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10"
            ),
        ] = None,
        mirroring_policy: Annotated[
            Optional[StrictStr],
            Field(
                description="Policy to set for mirroring content.  Must be one of additive."
            ),
        ] = None,
        verify_ssl_on_sync: Annotated[
            Optional[StrictBool],
            Field(
                description="if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA"
            ),
        ] = None,
        upstream_username: Annotated[
            Optional[StrictStr],
            Field(
                description="Username of the upstream repository user used for authentication"
            ),
        ] = None,
        upstream_password: Annotated[
            Optional[StrictStr],
            Field(
                description="Password of the upstream repository user used for authentication"
            ),
        ] = None,
        upstream_authentication_token: Annotated[
            Optional[StrictStr],
            Field(description="Password of the upstream authentication token."),
        ] = None,
        deb_releases: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of releases to be synced from deb-archive"
            ),
        ] = None,
        deb_components: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of repo components to be synced from deb-archive"
            ),
        ] = None,
        deb_architectures: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of architectures to be synced from deb-archive"
            ),
        ] = None,
        ignorable_content: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo"
            ),
        ] = None,
        ansible_collection_requirements: Annotated[
            Optional[StrictStr],
            Field(description="Contents of requirement yaml file to sync from URL"),
        ] = None,
        ansible_collection_auth_url: Annotated[
            Optional[StrictStr],
            Field(
                description="The URL to receive a session token from, e.g. used with Automation Hub."
            ),
        ] = None,
        ansible_collection_auth_token: Annotated[
            Optional[StrictStr],
            Field(description="The token key to use for authentication."),
        ] = None,
        http_proxy_policy: Annotated[
            Optional[StrictStr],
            Field(description="policies for HTTP proxy for content sync"),
        ] = None,
        http_proxy_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a HTTP Proxy"),
        ] = None,
        arch: Annotated[
            Optional[StrictStr],
            Field(description="Architecture of content in the repository"),
        ] = None,
        retain_package_versions_count: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="The maximum number of versions of each package to keep."
            ),
        ] = None,
        metadata_expire: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Time to expire yum metadata in seconds. Only relevant for custom yum repositories."
            ),
        ] = None,
        excludes: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0."
            ),
        ] = None,
        includes: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package."
            ),
        ] = None,
        package_types: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a custom repository


        :param name: Name of the repository (required)
        :type name: str
        :param product_id: Product the repository belongs to (required)
        :type product_id: float
        :param content_type: Type of repository. Available types endpoint: /katello/api/repositories/repository_types (required)
        :type content_type: str
        :param description: Description of the repository
        :type description: str
        :param label:
        :type label: str
        :param url: repository source url
        :type url: str
        :param os_versions: Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9
        :type os_versions: List[str]
        :param gpg_key_id: id of the gpg key that will be assigned to the new repository
        :type gpg_key_id: float
        :param ssl_ca_cert_id: Identifier of the content credential containing the SSL CA Cert
        :type ssl_ca_cert_id: float
        :param ssl_client_cert_id: Identifier of the content credential containing the SSL Client Cert
        :type ssl_client_cert_id: float
        :param ssl_client_key_id: Identifier of the content credential containing the SSL Client Key
        :type ssl_client_key_id: float
        :param unprotected: true if this repository can be published via HTTP
        :type unprotected: bool
        :param checksum_type: Checksum of the repository, currently 'sha1' & 'sha256' are supported
        :type checksum_type: str
        :param docker_upstream_name: Name of the upstream docker repository
        :type docker_upstream_name: str
        :param include_tags: Comma-separated list of tags to sync for a container image repository
        :type include_tags: List[str]
        :param exclude_tags: Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \\\"-source\\\"
        :type exclude_tags: List[str]
        :param download_policy: download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')
        :type download_policy: str
        :param download_concurrency: Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10
        :type download_concurrency: float
        :param mirroring_policy: Policy to set for mirroring content.  Must be one of additive.
        :type mirroring_policy: str
        :param verify_ssl_on_sync: if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA
        :type verify_ssl_on_sync: bool
        :param upstream_username: Username of the upstream repository user used for authentication
        :type upstream_username: str
        :param upstream_password: Password of the upstream repository user used for authentication
        :type upstream_password: str
        :param upstream_authentication_token: Password of the upstream authentication token.
        :type upstream_authentication_token: str
        :param deb_releases: whitespace-separated list of releases to be synced from deb-archive
        :type deb_releases: str
        :param deb_components: whitespace-separated list of repo components to be synced from deb-archive
        :type deb_components: str
        :param deb_architectures: whitespace-separated list of architectures to be synced from deb-archive
        :type deb_architectures: str
        :param ignorable_content: List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo
        :type ignorable_content: List[str]
        :param ansible_collection_requirements: Contents of requirement yaml file to sync from URL
        :type ansible_collection_requirements: str
        :param ansible_collection_auth_url: The URL to receive a session token from, e.g. used with Automation Hub.
        :type ansible_collection_auth_url: str
        :param ansible_collection_auth_token: The token key to use for authentication.
        :type ansible_collection_auth_token: str
        :param http_proxy_policy: policies for HTTP proxy for content sync
        :type http_proxy_policy: str
        :param http_proxy_id: ID of a HTTP Proxy
        :type http_proxy_id: float
        :param arch: Architecture of content in the repository
        :type arch: str
        :param retain_package_versions_count: The maximum number of versions of each package to keep.
        :type retain_package_versions_count: float
        :param metadata_expire: Time to expire yum metadata in seconds. Only relevant for custom yum repositories.
        :type metadata_expire: float
        :param excludes: Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0.
        :type excludes: List[str]
        :param includes: Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package.
        :type includes: List[str]
        :param package_types: Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist.
        :type package_types: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_serialize(
            name=name,
            product_id=product_id,
            content_type=content_type,
            description=description,
            label=label,
            url=url,
            os_versions=os_versions,
            gpg_key_id=gpg_key_id,
            ssl_ca_cert_id=ssl_ca_cert_id,
            ssl_client_cert_id=ssl_client_cert_id,
            ssl_client_key_id=ssl_client_key_id,
            unprotected=unprotected,
            checksum_type=checksum_type,
            docker_upstream_name=docker_upstream_name,
            include_tags=include_tags,
            exclude_tags=exclude_tags,
            download_policy=download_policy,
            download_concurrency=download_concurrency,
            mirroring_policy=mirroring_policy,
            verify_ssl_on_sync=verify_ssl_on_sync,
            upstream_username=upstream_username,
            upstream_password=upstream_password,
            upstream_authentication_token=upstream_authentication_token,
            deb_releases=deb_releases,
            deb_components=deb_components,
            deb_architectures=deb_architectures,
            ignorable_content=ignorable_content,
            ansible_collection_requirements=ansible_collection_requirements,
            ansible_collection_auth_url=ansible_collection_auth_url,
            ansible_collection_auth_token=ansible_collection_auth_token,
            http_proxy_policy=http_proxy_policy,
            http_proxy_id=http_proxy_id,
            arch=arch,
            retain_package_versions_count=retain_package_versions_count,
            metadata_expire=metadata_expire,
            excludes=excludes,
            includes=includes,
            package_types=package_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _post_repositories_serialize(
        self,
        name,
        product_id,
        content_type,
        description,
        label,
        url,
        os_versions,
        gpg_key_id,
        ssl_ca_cert_id,
        ssl_client_cert_id,
        ssl_client_key_id,
        unprotected,
        checksum_type,
        docker_upstream_name,
        include_tags,
        exclude_tags,
        download_policy,
        download_concurrency,
        mirroring_policy,
        verify_ssl_on_sync,
        upstream_username,
        upstream_password,
        upstream_authentication_token,
        deb_releases,
        deb_components,
        deb_architectures,
        ignorable_content,
        ansible_collection_requirements,
        ansible_collection_auth_url,
        ansible_collection_auth_token,
        http_proxy_policy,
        http_proxy_id,
        arch,
        retain_package_versions_count,
        metadata_expire,
        excludes,
        includes,
        package_types,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {
            "os_versions": "csv",
            "include_tags": "csv",
            "exclude_tags": "csv",
            "ignorable_content": "csv",
            "excludes": "csv",
            "includes": "csv",
            "package_types": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if name is not None:
            _form_params.append(("name", name))
        if product_id is not None:
            _form_params.append(("product_id", product_id))
        if content_type is not None:
            _form_params.append(("content_type", content_type))
        if description is not None:
            _form_params.append(("description", description))
        if label is not None:
            _form_params.append(("label", label))
        if url is not None:
            _form_params.append(("url", url))
        if os_versions is not None:
            _form_params.append(("os_versions", os_versions))
        if gpg_key_id is not None:
            _form_params.append(("gpg_key_id", gpg_key_id))
        if ssl_ca_cert_id is not None:
            _form_params.append(("ssl_ca_cert_id", ssl_ca_cert_id))
        if ssl_client_cert_id is not None:
            _form_params.append(("ssl_client_cert_id", ssl_client_cert_id))
        if ssl_client_key_id is not None:
            _form_params.append(("ssl_client_key_id", ssl_client_key_id))
        if unprotected is not None:
            _form_params.append(("unprotected", unprotected))
        if checksum_type is not None:
            _form_params.append(("checksum_type", checksum_type))
        if docker_upstream_name is not None:
            _form_params.append(("docker_upstream_name", docker_upstream_name))
        if include_tags is not None:
            _form_params.append(("include_tags", include_tags))
        if exclude_tags is not None:
            _form_params.append(("exclude_tags", exclude_tags))
        if download_policy is not None:
            _form_params.append(("download_policy", download_policy))
        if download_concurrency is not None:
            _form_params.append(("download_concurrency", download_concurrency))
        if mirroring_policy is not None:
            _form_params.append(("mirroring_policy", mirroring_policy))
        if verify_ssl_on_sync is not None:
            _form_params.append(("verify_ssl_on_sync", verify_ssl_on_sync))
        if upstream_username is not None:
            _form_params.append(("upstream_username", upstream_username))
        if upstream_password is not None:
            _form_params.append(("upstream_password", upstream_password))
        if upstream_authentication_token is not None:
            _form_params.append(
                ("upstream_authentication_token", upstream_authentication_token)
            )
        if deb_releases is not None:
            _form_params.append(("deb_releases", deb_releases))
        if deb_components is not None:
            _form_params.append(("deb_components", deb_components))
        if deb_architectures is not None:
            _form_params.append(("deb_architectures", deb_architectures))
        if ignorable_content is not None:
            _form_params.append(("ignorable_content", ignorable_content))
        if ansible_collection_requirements is not None:
            _form_params.append(
                ("ansible_collection_requirements", ansible_collection_requirements)
            )
        if ansible_collection_auth_url is not None:
            _form_params.append(
                ("ansible_collection_auth_url", ansible_collection_auth_url)
            )
        if ansible_collection_auth_token is not None:
            _form_params.append(
                ("ansible_collection_auth_token", ansible_collection_auth_token)
            )
        if http_proxy_policy is not None:
            _form_params.append(("http_proxy_policy", http_proxy_policy))
        if http_proxy_id is not None:
            _form_params.append(("http_proxy_id", http_proxy_id))
        if arch is not None:
            _form_params.append(("arch", arch))
        if retain_package_versions_count is not None:
            _form_params.append(
                ("retain_package_versions_count", retain_package_versions_count)
            )
        if metadata_expire is not None:
            _form_params.append(("metadata_expire", metadata_expire))
        if excludes is not None:
            _form_params.append(("excludes", excludes))
        if includes is not None:
            _form_params.append(("includes", includes))
        if package_types is not None:
            _form_params.append(("package_types", package_types))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/repositories",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def post_repositories_id_reclaim_space(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Reclaim space from an On Demand repository


        :param id: repository ID (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_id_reclaim_space_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def post_repositories_id_reclaim_space_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Reclaim space from an On Demand repository


        :param id: repository ID (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_id_reclaim_space_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def post_repositories_id_reclaim_space_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Reclaim space from an On Demand repository


        :param id: repository ID (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_id_reclaim_space_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _post_repositories_id_reclaim_space_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/repositories/{id}/reclaim_space",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def post_repositories_id_sync(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        source_url: Annotated[
            Optional[StrictStr],
            Field(description="temporarily override feed URL for sync"),
        ] = None,
        incremental: Annotated[
            Optional[StrictBool], Field(description="perform an incremental import")
        ] = None,
        skip_metadata_check: Annotated[
            Optional[StrictBool],
            Field(
                description="Force sync even if no upstream changes are detected. Only used with yum or deb repositories."
            ),
        ] = None,
        validate_contents: Annotated[
            Optional[StrictBool],
            Field(
                description="Force a sync and validate the checksums of all content. Only used with yum repositories."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Sync a repository


        :param id: repository ID (required)
        :type id: float
        :param source_url: temporarily override feed URL for sync
        :type source_url: str
        :param incremental: perform an incremental import
        :type incremental: bool
        :param skip_metadata_check: Force sync even if no upstream changes are detected. Only used with yum or deb repositories.
        :type skip_metadata_check: bool
        :param validate_contents: Force a sync and validate the checksums of all content. Only used with yum repositories.
        :type validate_contents: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_id_sync_serialize(
            id=id,
            source_url=source_url,
            incremental=incremental,
            skip_metadata_check=skip_metadata_check,
            validate_contents=validate_contents,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def post_repositories_id_sync_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        source_url: Annotated[
            Optional[StrictStr],
            Field(description="temporarily override feed URL for sync"),
        ] = None,
        incremental: Annotated[
            Optional[StrictBool], Field(description="perform an incremental import")
        ] = None,
        skip_metadata_check: Annotated[
            Optional[StrictBool],
            Field(
                description="Force sync even if no upstream changes are detected. Only used with yum or deb repositories."
            ),
        ] = None,
        validate_contents: Annotated[
            Optional[StrictBool],
            Field(
                description="Force a sync and validate the checksums of all content. Only used with yum repositories."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Sync a repository


        :param id: repository ID (required)
        :type id: float
        :param source_url: temporarily override feed URL for sync
        :type source_url: str
        :param incremental: perform an incremental import
        :type incremental: bool
        :param skip_metadata_check: Force sync even if no upstream changes are detected. Only used with yum or deb repositories.
        :type skip_metadata_check: bool
        :param validate_contents: Force a sync and validate the checksums of all content. Only used with yum repositories.
        :type validate_contents: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_id_sync_serialize(
            id=id,
            source_url=source_url,
            incremental=incremental,
            skip_metadata_check=skip_metadata_check,
            validate_contents=validate_contents,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def post_repositories_id_sync_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        source_url: Annotated[
            Optional[StrictStr],
            Field(description="temporarily override feed URL for sync"),
        ] = None,
        incremental: Annotated[
            Optional[StrictBool], Field(description="perform an incremental import")
        ] = None,
        skip_metadata_check: Annotated[
            Optional[StrictBool],
            Field(
                description="Force sync even if no upstream changes are detected. Only used with yum or deb repositories."
            ),
        ] = None,
        validate_contents: Annotated[
            Optional[StrictBool],
            Field(
                description="Force a sync and validate the checksums of all content. Only used with yum repositories."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Sync a repository


        :param id: repository ID (required)
        :type id: float
        :param source_url: temporarily override feed URL for sync
        :type source_url: str
        :param incremental: perform an incremental import
        :type incremental: bool
        :param skip_metadata_check: Force sync even if no upstream changes are detected. Only used with yum or deb repositories.
        :type skip_metadata_check: bool
        :param validate_contents: Force a sync and validate the checksums of all content. Only used with yum repositories.
        :type validate_contents: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_id_sync_serialize(
            id=id,
            source_url=source_url,
            incremental=incremental,
            skip_metadata_check=skip_metadata_check,
            validate_contents=validate_contents,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _post_repositories_id_sync_serialize(
        self,
        id,
        source_url,
        incremental,
        skip_metadata_check,
        validate_contents,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if source_url is not None:
            _form_params.append(("source_url", source_url))
        if incremental is not None:
            _form_params.append(("incremental", incremental))
        if skip_metadata_check is not None:
            _form_params.append(("skip_metadata_check", skip_metadata_check))
        if validate_contents is not None:
            _form_params.append(("validate_contents", validate_contents))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/repositories/{id}/sync",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def post_repositories_id_upload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        content: Annotated[
            Union[StrictBytes, StrictStr],
            Field(
                description="Content files to upload. Can be a single file or array of files."
            ),
        ],
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="The type of content to upload (srpm, file, etc.). Check uploadable types here: /katello/api/repositories/repository_types"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Upload content into the repository


        :param id: repository ID (required)
        :type id: float
        :param content: Content files to upload. Can be a single file or array of files. (required)
        :type content: bytearray
        :param content_type: The type of content to upload (srpm, file, etc.). Check uploadable types here: /katello/api/repositories/repository_types
        :type content_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_id_upload_content_serialize(
            id=id,
            content=content,
            content_type=content_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def post_repositories_id_upload_content_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        content: Annotated[
            Union[StrictBytes, StrictStr],
            Field(
                description="Content files to upload. Can be a single file or array of files."
            ),
        ],
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="The type of content to upload (srpm, file, etc.). Check uploadable types here: /katello/api/repositories/repository_types"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Upload content into the repository


        :param id: repository ID (required)
        :type id: float
        :param content: Content files to upload. Can be a single file or array of files. (required)
        :type content: bytearray
        :param content_type: The type of content to upload (srpm, file, etc.). Check uploadable types here: /katello/api/repositories/repository_types
        :type content_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_id_upload_content_serialize(
            id=id,
            content=content,
            content_type=content_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def post_repositories_id_upload_content_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        content: Annotated[
            Union[StrictBytes, StrictStr],
            Field(
                description="Content files to upload. Can be a single file or array of files."
            ),
        ],
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="The type of content to upload (srpm, file, etc.). Check uploadable types here: /katello/api/repositories/repository_types"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Upload content into the repository


        :param id: repository ID (required)
        :type id: float
        :param content: Content files to upload. Can be a single file or array of files. (required)
        :type content: bytearray
        :param content_type: The type of content to upload (srpm, file, etc.). Check uploadable types here: /katello/api/repositories/repository_types
        :type content_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_id_upload_content_serialize(
            id=id,
            content=content,
            content_type=content_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _post_repositories_id_upload_content_serialize(
        self,
        id,
        content,
        content_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if content is not None:
            _files["content"] = content
        if content_type is not None:
            _form_params.append(("content_type", content_type))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/repositories/{id}/upload_content",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def post_repositories_id_verify_checksum(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Verify checksum of repository contents


        :param id: repository ID (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_id_verify_checksum_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def post_repositories_id_verify_checksum_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Verify checksum of repository contents


        :param id: repository ID (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_id_verify_checksum_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def post_repositories_id_verify_checksum_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Verify checksum of repository contents


        :param id: repository ID (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_repositories_id_verify_checksum_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _post_repositories_id_verify_checksum_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/repositories/{id}/verify_checksum",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def put_repositories_id(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        name: Optional[StrictStr] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        url: Annotated[
            Optional[StrictStr], Field(description="repository source url")
        ] = None,
        os_versions: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9"
            ),
        ] = None,
        gpg_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="id of the gpg key that will be assigned to the new repository"
            ),
        ] = None,
        ssl_ca_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL CA Cert"
            ),
        ] = None,
        ssl_client_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL Client Cert"
            ),
        ] = None,
        ssl_client_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL Client Key"
            ),
        ] = None,
        unprotected: Annotated[
            Optional[StrictBool],
            Field(description="true if this repository can be published via HTTP"),
        ] = None,
        checksum_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Checksum of the repository, currently 'sha1' & 'sha256' are supported"
            ),
        ] = None,
        docker_upstream_name: Annotated[
            Optional[StrictStr],
            Field(description="Name of the upstream docker repository"),
        ] = None,
        include_tags: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Comma-separated list of tags to sync for a container image repository"
            ),
        ] = None,
        exclude_tags: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \\"-source\\"'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(
                description="download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')"
            ),
        ] = None,
        download_concurrency: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10"
            ),
        ] = None,
        mirroring_policy: Annotated[
            Optional[StrictStr],
            Field(
                description="Policy to set for mirroring content.  Must be one of additive."
            ),
        ] = None,
        verify_ssl_on_sync: Annotated[
            Optional[StrictBool],
            Field(
                description="if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA"
            ),
        ] = None,
        upstream_username: Annotated[
            Optional[StrictStr],
            Field(
                description="Username of the upstream repository user used for authentication"
            ),
        ] = None,
        upstream_password: Annotated[
            Optional[StrictStr],
            Field(
                description="Password of the upstream repository user used for authentication"
            ),
        ] = None,
        upstream_authentication_token: Annotated[
            Optional[StrictStr],
            Field(description="Password of the upstream authentication token."),
        ] = None,
        deb_releases: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of releases to be synced from deb-archive"
            ),
        ] = None,
        deb_components: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of repo components to be synced from deb-archive"
            ),
        ] = None,
        deb_architectures: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of architectures to be synced from deb-archive"
            ),
        ] = None,
        ignorable_content: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo"
            ),
        ] = None,
        ansible_collection_requirements: Annotated[
            Optional[StrictStr],
            Field(description="Contents of requirement yaml file to sync from URL"),
        ] = None,
        ansible_collection_auth_url: Annotated[
            Optional[StrictStr],
            Field(
                description="The URL to receive a session token from, e.g. used with Automation Hub."
            ),
        ] = None,
        ansible_collection_auth_token: Annotated[
            Optional[StrictStr],
            Field(description="The token key to use for authentication."),
        ] = None,
        http_proxy_policy: Annotated[
            Optional[StrictStr],
            Field(description="policies for HTTP proxy for content sync"),
        ] = None,
        http_proxy_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a HTTP Proxy"),
        ] = None,
        arch: Annotated[
            Optional[StrictStr],
            Field(description="Architecture of content in the repository"),
        ] = None,
        retain_package_versions_count: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="The maximum number of versions of each package to keep."
            ),
        ] = None,
        metadata_expire: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Time to expire yum metadata in seconds. Only relevant for custom yum repositories."
            ),
        ] = None,
        excludes: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0."
            ),
        ] = None,
        includes: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package."
            ),
        ] = None,
        package_types: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Update a repository


        :param id: repository ID (required)
        :type id: float
        :param name:
        :type name: str
        :param description: description of the repository
        :type description: str
        :param url: repository source url
        :type url: str
        :param os_versions: Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9
        :type os_versions: List[str]
        :param gpg_key_id: id of the gpg key that will be assigned to the new repository
        :type gpg_key_id: float
        :param ssl_ca_cert_id: Identifier of the content credential containing the SSL CA Cert
        :type ssl_ca_cert_id: float
        :param ssl_client_cert_id: Identifier of the content credential containing the SSL Client Cert
        :type ssl_client_cert_id: float
        :param ssl_client_key_id: Identifier of the content credential containing the SSL Client Key
        :type ssl_client_key_id: float
        :param unprotected: true if this repository can be published via HTTP
        :type unprotected: bool
        :param checksum_type: Checksum of the repository, currently 'sha1' & 'sha256' are supported
        :type checksum_type: str
        :param docker_upstream_name: Name of the upstream docker repository
        :type docker_upstream_name: str
        :param include_tags: Comma-separated list of tags to sync for a container image repository
        :type include_tags: List[str]
        :param exclude_tags: Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \\\"-source\\\"
        :type exclude_tags: List[str]
        :param download_policy: download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')
        :type download_policy: str
        :param download_concurrency: Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10
        :type download_concurrency: float
        :param mirroring_policy: Policy to set for mirroring content.  Must be one of additive.
        :type mirroring_policy: str
        :param verify_ssl_on_sync: if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA
        :type verify_ssl_on_sync: bool
        :param upstream_username: Username of the upstream repository user used for authentication
        :type upstream_username: str
        :param upstream_password: Password of the upstream repository user used for authentication
        :type upstream_password: str
        :param upstream_authentication_token: Password of the upstream authentication token.
        :type upstream_authentication_token: str
        :param deb_releases: whitespace-separated list of releases to be synced from deb-archive
        :type deb_releases: str
        :param deb_components: whitespace-separated list of repo components to be synced from deb-archive
        :type deb_components: str
        :param deb_architectures: whitespace-separated list of architectures to be synced from deb-archive
        :type deb_architectures: str
        :param ignorable_content: List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo
        :type ignorable_content: List[str]
        :param ansible_collection_requirements: Contents of requirement yaml file to sync from URL
        :type ansible_collection_requirements: str
        :param ansible_collection_auth_url: The URL to receive a session token from, e.g. used with Automation Hub.
        :type ansible_collection_auth_url: str
        :param ansible_collection_auth_token: The token key to use for authentication.
        :type ansible_collection_auth_token: str
        :param http_proxy_policy: policies for HTTP proxy for content sync
        :type http_proxy_policy: str
        :param http_proxy_id: ID of a HTTP Proxy
        :type http_proxy_id: float
        :param arch: Architecture of content in the repository
        :type arch: str
        :param retain_package_versions_count: The maximum number of versions of each package to keep.
        :type retain_package_versions_count: float
        :param metadata_expire: Time to expire yum metadata in seconds. Only relevant for custom yum repositories.
        :type metadata_expire: float
        :param excludes: Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0.
        :type excludes: List[str]
        :param includes: Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package.
        :type includes: List[str]
        :param package_types: Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist.
        :type package_types: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_serialize(
            id=id,
            name=name,
            description=description,
            url=url,
            os_versions=os_versions,
            gpg_key_id=gpg_key_id,
            ssl_ca_cert_id=ssl_ca_cert_id,
            ssl_client_cert_id=ssl_client_cert_id,
            ssl_client_key_id=ssl_client_key_id,
            unprotected=unprotected,
            checksum_type=checksum_type,
            docker_upstream_name=docker_upstream_name,
            include_tags=include_tags,
            exclude_tags=exclude_tags,
            download_policy=download_policy,
            download_concurrency=download_concurrency,
            mirroring_policy=mirroring_policy,
            verify_ssl_on_sync=verify_ssl_on_sync,
            upstream_username=upstream_username,
            upstream_password=upstream_password,
            upstream_authentication_token=upstream_authentication_token,
            deb_releases=deb_releases,
            deb_components=deb_components,
            deb_architectures=deb_architectures,
            ignorable_content=ignorable_content,
            ansible_collection_requirements=ansible_collection_requirements,
            ansible_collection_auth_url=ansible_collection_auth_url,
            ansible_collection_auth_token=ansible_collection_auth_token,
            http_proxy_policy=http_proxy_policy,
            http_proxy_id=http_proxy_id,
            arch=arch,
            retain_package_versions_count=retain_package_versions_count,
            metadata_expire=metadata_expire,
            excludes=excludes,
            includes=includes,
            package_types=package_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def put_repositories_id_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        name: Optional[StrictStr] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        url: Annotated[
            Optional[StrictStr], Field(description="repository source url")
        ] = None,
        os_versions: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9"
            ),
        ] = None,
        gpg_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="id of the gpg key that will be assigned to the new repository"
            ),
        ] = None,
        ssl_ca_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL CA Cert"
            ),
        ] = None,
        ssl_client_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL Client Cert"
            ),
        ] = None,
        ssl_client_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL Client Key"
            ),
        ] = None,
        unprotected: Annotated[
            Optional[StrictBool],
            Field(description="true if this repository can be published via HTTP"),
        ] = None,
        checksum_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Checksum of the repository, currently 'sha1' & 'sha256' are supported"
            ),
        ] = None,
        docker_upstream_name: Annotated[
            Optional[StrictStr],
            Field(description="Name of the upstream docker repository"),
        ] = None,
        include_tags: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Comma-separated list of tags to sync for a container image repository"
            ),
        ] = None,
        exclude_tags: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \\"-source\\"'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(
                description="download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')"
            ),
        ] = None,
        download_concurrency: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10"
            ),
        ] = None,
        mirroring_policy: Annotated[
            Optional[StrictStr],
            Field(
                description="Policy to set for mirroring content.  Must be one of additive."
            ),
        ] = None,
        verify_ssl_on_sync: Annotated[
            Optional[StrictBool],
            Field(
                description="if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA"
            ),
        ] = None,
        upstream_username: Annotated[
            Optional[StrictStr],
            Field(
                description="Username of the upstream repository user used for authentication"
            ),
        ] = None,
        upstream_password: Annotated[
            Optional[StrictStr],
            Field(
                description="Password of the upstream repository user used for authentication"
            ),
        ] = None,
        upstream_authentication_token: Annotated[
            Optional[StrictStr],
            Field(description="Password of the upstream authentication token."),
        ] = None,
        deb_releases: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of releases to be synced from deb-archive"
            ),
        ] = None,
        deb_components: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of repo components to be synced from deb-archive"
            ),
        ] = None,
        deb_architectures: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of architectures to be synced from deb-archive"
            ),
        ] = None,
        ignorable_content: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo"
            ),
        ] = None,
        ansible_collection_requirements: Annotated[
            Optional[StrictStr],
            Field(description="Contents of requirement yaml file to sync from URL"),
        ] = None,
        ansible_collection_auth_url: Annotated[
            Optional[StrictStr],
            Field(
                description="The URL to receive a session token from, e.g. used with Automation Hub."
            ),
        ] = None,
        ansible_collection_auth_token: Annotated[
            Optional[StrictStr],
            Field(description="The token key to use for authentication."),
        ] = None,
        http_proxy_policy: Annotated[
            Optional[StrictStr],
            Field(description="policies for HTTP proxy for content sync"),
        ] = None,
        http_proxy_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a HTTP Proxy"),
        ] = None,
        arch: Annotated[
            Optional[StrictStr],
            Field(description="Architecture of content in the repository"),
        ] = None,
        retain_package_versions_count: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="The maximum number of versions of each package to keep."
            ),
        ] = None,
        metadata_expire: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Time to expire yum metadata in seconds. Only relevant for custom yum repositories."
            ),
        ] = None,
        excludes: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0."
            ),
        ] = None,
        includes: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package."
            ),
        ] = None,
        package_types: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Update a repository


        :param id: repository ID (required)
        :type id: float
        :param name:
        :type name: str
        :param description: description of the repository
        :type description: str
        :param url: repository source url
        :type url: str
        :param os_versions: Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9
        :type os_versions: List[str]
        :param gpg_key_id: id of the gpg key that will be assigned to the new repository
        :type gpg_key_id: float
        :param ssl_ca_cert_id: Identifier of the content credential containing the SSL CA Cert
        :type ssl_ca_cert_id: float
        :param ssl_client_cert_id: Identifier of the content credential containing the SSL Client Cert
        :type ssl_client_cert_id: float
        :param ssl_client_key_id: Identifier of the content credential containing the SSL Client Key
        :type ssl_client_key_id: float
        :param unprotected: true if this repository can be published via HTTP
        :type unprotected: bool
        :param checksum_type: Checksum of the repository, currently 'sha1' & 'sha256' are supported
        :type checksum_type: str
        :param docker_upstream_name: Name of the upstream docker repository
        :type docker_upstream_name: str
        :param include_tags: Comma-separated list of tags to sync for a container image repository
        :type include_tags: List[str]
        :param exclude_tags: Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \\\"-source\\\"
        :type exclude_tags: List[str]
        :param download_policy: download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')
        :type download_policy: str
        :param download_concurrency: Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10
        :type download_concurrency: float
        :param mirroring_policy: Policy to set for mirroring content.  Must be one of additive.
        :type mirroring_policy: str
        :param verify_ssl_on_sync: if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA
        :type verify_ssl_on_sync: bool
        :param upstream_username: Username of the upstream repository user used for authentication
        :type upstream_username: str
        :param upstream_password: Password of the upstream repository user used for authentication
        :type upstream_password: str
        :param upstream_authentication_token: Password of the upstream authentication token.
        :type upstream_authentication_token: str
        :param deb_releases: whitespace-separated list of releases to be synced from deb-archive
        :type deb_releases: str
        :param deb_components: whitespace-separated list of repo components to be synced from deb-archive
        :type deb_components: str
        :param deb_architectures: whitespace-separated list of architectures to be synced from deb-archive
        :type deb_architectures: str
        :param ignorable_content: List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo
        :type ignorable_content: List[str]
        :param ansible_collection_requirements: Contents of requirement yaml file to sync from URL
        :type ansible_collection_requirements: str
        :param ansible_collection_auth_url: The URL to receive a session token from, e.g. used with Automation Hub.
        :type ansible_collection_auth_url: str
        :param ansible_collection_auth_token: The token key to use for authentication.
        :type ansible_collection_auth_token: str
        :param http_proxy_policy: policies for HTTP proxy for content sync
        :type http_proxy_policy: str
        :param http_proxy_id: ID of a HTTP Proxy
        :type http_proxy_id: float
        :param arch: Architecture of content in the repository
        :type arch: str
        :param retain_package_versions_count: The maximum number of versions of each package to keep.
        :type retain_package_versions_count: float
        :param metadata_expire: Time to expire yum metadata in seconds. Only relevant for custom yum repositories.
        :type metadata_expire: float
        :param excludes: Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0.
        :type excludes: List[str]
        :param includes: Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package.
        :type includes: List[str]
        :param package_types: Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist.
        :type package_types: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_serialize(
            id=id,
            name=name,
            description=description,
            url=url,
            os_versions=os_versions,
            gpg_key_id=gpg_key_id,
            ssl_ca_cert_id=ssl_ca_cert_id,
            ssl_client_cert_id=ssl_client_cert_id,
            ssl_client_key_id=ssl_client_key_id,
            unprotected=unprotected,
            checksum_type=checksum_type,
            docker_upstream_name=docker_upstream_name,
            include_tags=include_tags,
            exclude_tags=exclude_tags,
            download_policy=download_policy,
            download_concurrency=download_concurrency,
            mirroring_policy=mirroring_policy,
            verify_ssl_on_sync=verify_ssl_on_sync,
            upstream_username=upstream_username,
            upstream_password=upstream_password,
            upstream_authentication_token=upstream_authentication_token,
            deb_releases=deb_releases,
            deb_components=deb_components,
            deb_architectures=deb_architectures,
            ignorable_content=ignorable_content,
            ansible_collection_requirements=ansible_collection_requirements,
            ansible_collection_auth_url=ansible_collection_auth_url,
            ansible_collection_auth_token=ansible_collection_auth_token,
            http_proxy_policy=http_proxy_policy,
            http_proxy_id=http_proxy_id,
            arch=arch,
            retain_package_versions_count=retain_package_versions_count,
            metadata_expire=metadata_expire,
            excludes=excludes,
            includes=includes,
            package_types=package_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def put_repositories_id_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        name: Optional[StrictStr] = None,
        description: Annotated[
            Optional[StrictStr], Field(description="description of the repository")
        ] = None,
        url: Annotated[
            Optional[StrictStr], Field(description="repository source url")
        ] = None,
        os_versions: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9"
            ),
        ] = None,
        gpg_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="id of the gpg key that will be assigned to the new repository"
            ),
        ] = None,
        ssl_ca_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL CA Cert"
            ),
        ] = None,
        ssl_client_cert_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL Client Cert"
            ),
        ] = None,
        ssl_client_key_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Identifier of the content credential containing the SSL Client Key"
            ),
        ] = None,
        unprotected: Annotated[
            Optional[StrictBool],
            Field(description="true if this repository can be published via HTTP"),
        ] = None,
        checksum_type: Annotated[
            Optional[StrictStr],
            Field(
                description="Checksum of the repository, currently 'sha1' & 'sha256' are supported"
            ),
        ] = None,
        docker_upstream_name: Annotated[
            Optional[StrictStr],
            Field(description="Name of the upstream docker repository"),
        ] = None,
        include_tags: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Comma-separated list of tags to sync for a container image repository"
            ),
        ] = None,
        exclude_tags: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \\"-source\\"'
            ),
        ] = None,
        download_policy: Annotated[
            Optional[StrictStr],
            Field(
                description="download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')"
            ),
        ] = None,
        download_concurrency: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10"
            ),
        ] = None,
        mirroring_policy: Annotated[
            Optional[StrictStr],
            Field(
                description="Policy to set for mirroring content.  Must be one of additive."
            ),
        ] = None,
        verify_ssl_on_sync: Annotated[
            Optional[StrictBool],
            Field(
                description="if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA"
            ),
        ] = None,
        upstream_username: Annotated[
            Optional[StrictStr],
            Field(
                description="Username of the upstream repository user used for authentication"
            ),
        ] = None,
        upstream_password: Annotated[
            Optional[StrictStr],
            Field(
                description="Password of the upstream repository user used for authentication"
            ),
        ] = None,
        upstream_authentication_token: Annotated[
            Optional[StrictStr],
            Field(description="Password of the upstream authentication token."),
        ] = None,
        deb_releases: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of releases to be synced from deb-archive"
            ),
        ] = None,
        deb_components: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of repo components to be synced from deb-archive"
            ),
        ] = None,
        deb_architectures: Annotated[
            Optional[StrictStr],
            Field(
                description="whitespace-separated list of architectures to be synced from deb-archive"
            ),
        ] = None,
        ignorable_content: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo"
            ),
        ] = None,
        ansible_collection_requirements: Annotated[
            Optional[StrictStr],
            Field(description="Contents of requirement yaml file to sync from URL"),
        ] = None,
        ansible_collection_auth_url: Annotated[
            Optional[StrictStr],
            Field(
                description="The URL to receive a session token from, e.g. used with Automation Hub."
            ),
        ] = None,
        ansible_collection_auth_token: Annotated[
            Optional[StrictStr],
            Field(description="The token key to use for authentication."),
        ] = None,
        http_proxy_policy: Annotated[
            Optional[StrictStr],
            Field(description="policies for HTTP proxy for content sync"),
        ] = None,
        http_proxy_id: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="ID of a HTTP Proxy"),
        ] = None,
        arch: Annotated[
            Optional[StrictStr],
            Field(description="Architecture of content in the repository"),
        ] = None,
        retain_package_versions_count: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="The maximum number of versions of each package to keep."
            ),
        ] = None,
        metadata_expire: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(
                description="Time to expire yum metadata in seconds. Only relevant for custom yum repositories."
            ),
        ] = None,
        excludes: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0."
            ),
        ] = None,
        includes: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package."
            ),
        ] = None,
        package_types: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update a repository


        :param id: repository ID (required)
        :type id: float
        :param name:
        :type name: str
        :param description: description of the repository
        :type description: str
        :param url: repository source url
        :type url: str
        :param os_versions: Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9
        :type os_versions: List[str]
        :param gpg_key_id: id of the gpg key that will be assigned to the new repository
        :type gpg_key_id: float
        :param ssl_ca_cert_id: Identifier of the content credential containing the SSL CA Cert
        :type ssl_ca_cert_id: float
        :param ssl_client_cert_id: Identifier of the content credential containing the SSL Client Cert
        :type ssl_client_cert_id: float
        :param ssl_client_key_id: Identifier of the content credential containing the SSL Client Key
        :type ssl_client_key_id: float
        :param unprotected: true if this repository can be published via HTTP
        :type unprotected: bool
        :param checksum_type: Checksum of the repository, currently 'sha1' & 'sha256' are supported
        :type checksum_type: str
        :param docker_upstream_name: Name of the upstream docker repository
        :type docker_upstream_name: str
        :param include_tags: Comma-separated list of tags to sync for a container image repository
        :type include_tags: List[str]
        :param exclude_tags: Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \\\"-source\\\"
        :type exclude_tags: List[str]
        :param download_policy: download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')
        :type download_policy: str
        :param download_concurrency: Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10
        :type download_concurrency: float
        :param mirroring_policy: Policy to set for mirroring content.  Must be one of additive.
        :type mirroring_policy: str
        :param verify_ssl_on_sync: if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA
        :type verify_ssl_on_sync: bool
        :param upstream_username: Username of the upstream repository user used for authentication
        :type upstream_username: str
        :param upstream_password: Password of the upstream repository user used for authentication
        :type upstream_password: str
        :param upstream_authentication_token: Password of the upstream authentication token.
        :type upstream_authentication_token: str
        :param deb_releases: whitespace-separated list of releases to be synced from deb-archive
        :type deb_releases: str
        :param deb_components: whitespace-separated list of repo components to be synced from deb-archive
        :type deb_components: str
        :param deb_architectures: whitespace-separated list of architectures to be synced from deb-archive
        :type deb_architectures: str
        :param ignorable_content: List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo
        :type ignorable_content: List[str]
        :param ansible_collection_requirements: Contents of requirement yaml file to sync from URL
        :type ansible_collection_requirements: str
        :param ansible_collection_auth_url: The URL to receive a session token from, e.g. used with Automation Hub.
        :type ansible_collection_auth_url: str
        :param ansible_collection_auth_token: The token key to use for authentication.
        :type ansible_collection_auth_token: str
        :param http_proxy_policy: policies for HTTP proxy for content sync
        :type http_proxy_policy: str
        :param http_proxy_id: ID of a HTTP Proxy
        :type http_proxy_id: float
        :param arch: Architecture of content in the repository
        :type arch: str
        :param retain_package_versions_count: The maximum number of versions of each package to keep.
        :type retain_package_versions_count: float
        :param metadata_expire: Time to expire yum metadata in seconds. Only relevant for custom yum repositories.
        :type metadata_expire: float
        :param excludes: Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0.
        :type excludes: List[str]
        :param includes: Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package.
        :type includes: List[str]
        :param package_types: Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist.
        :type package_types: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_serialize(
            id=id,
            name=name,
            description=description,
            url=url,
            os_versions=os_versions,
            gpg_key_id=gpg_key_id,
            ssl_ca_cert_id=ssl_ca_cert_id,
            ssl_client_cert_id=ssl_client_cert_id,
            ssl_client_key_id=ssl_client_key_id,
            unprotected=unprotected,
            checksum_type=checksum_type,
            docker_upstream_name=docker_upstream_name,
            include_tags=include_tags,
            exclude_tags=exclude_tags,
            download_policy=download_policy,
            download_concurrency=download_concurrency,
            mirroring_policy=mirroring_policy,
            verify_ssl_on_sync=verify_ssl_on_sync,
            upstream_username=upstream_username,
            upstream_password=upstream_password,
            upstream_authentication_token=upstream_authentication_token,
            deb_releases=deb_releases,
            deb_components=deb_components,
            deb_architectures=deb_architectures,
            ignorable_content=ignorable_content,
            ansible_collection_requirements=ansible_collection_requirements,
            ansible_collection_auth_url=ansible_collection_auth_url,
            ansible_collection_auth_token=ansible_collection_auth_token,
            http_proxy_policy=http_proxy_policy,
            http_proxy_id=http_proxy_id,
            arch=arch,
            retain_package_versions_count=retain_package_versions_count,
            metadata_expire=metadata_expire,
            excludes=excludes,
            includes=includes,
            package_types=package_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _put_repositories_id_serialize(
        self,
        id,
        name,
        description,
        url,
        os_versions,
        gpg_key_id,
        ssl_ca_cert_id,
        ssl_client_cert_id,
        ssl_client_key_id,
        unprotected,
        checksum_type,
        docker_upstream_name,
        include_tags,
        exclude_tags,
        download_policy,
        download_concurrency,
        mirroring_policy,
        verify_ssl_on_sync,
        upstream_username,
        upstream_password,
        upstream_authentication_token,
        deb_releases,
        deb_components,
        deb_architectures,
        ignorable_content,
        ansible_collection_requirements,
        ansible_collection_auth_url,
        ansible_collection_auth_token,
        http_proxy_policy,
        http_proxy_id,
        arch,
        retain_package_versions_count,
        metadata_expire,
        excludes,
        includes,
        package_types,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {
            "os_versions": "csv",
            "include_tags": "csv",
            "exclude_tags": "csv",
            "ignorable_content": "csv",
            "excludes": "csv",
            "includes": "csv",
            "package_types": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if name is not None:
            _form_params.append(("name", name))
        if description is not None:
            _form_params.append(("description", description))
        if url is not None:
            _form_params.append(("url", url))
        if os_versions is not None:
            _form_params.append(("os_versions", os_versions))
        if gpg_key_id is not None:
            _form_params.append(("gpg_key_id", gpg_key_id))
        if ssl_ca_cert_id is not None:
            _form_params.append(("ssl_ca_cert_id", ssl_ca_cert_id))
        if ssl_client_cert_id is not None:
            _form_params.append(("ssl_client_cert_id", ssl_client_cert_id))
        if ssl_client_key_id is not None:
            _form_params.append(("ssl_client_key_id", ssl_client_key_id))
        if unprotected is not None:
            _form_params.append(("unprotected", unprotected))
        if checksum_type is not None:
            _form_params.append(("checksum_type", checksum_type))
        if docker_upstream_name is not None:
            _form_params.append(("docker_upstream_name", docker_upstream_name))
        if include_tags is not None:
            _form_params.append(("include_tags", include_tags))
        if exclude_tags is not None:
            _form_params.append(("exclude_tags", exclude_tags))
        if download_policy is not None:
            _form_params.append(("download_policy", download_policy))
        if download_concurrency is not None:
            _form_params.append(("download_concurrency", download_concurrency))
        if mirroring_policy is not None:
            _form_params.append(("mirroring_policy", mirroring_policy))
        if verify_ssl_on_sync is not None:
            _form_params.append(("verify_ssl_on_sync", verify_ssl_on_sync))
        if upstream_username is not None:
            _form_params.append(("upstream_username", upstream_username))
        if upstream_password is not None:
            _form_params.append(("upstream_password", upstream_password))
        if upstream_authentication_token is not None:
            _form_params.append(
                ("upstream_authentication_token", upstream_authentication_token)
            )
        if deb_releases is not None:
            _form_params.append(("deb_releases", deb_releases))
        if deb_components is not None:
            _form_params.append(("deb_components", deb_components))
        if deb_architectures is not None:
            _form_params.append(("deb_architectures", deb_architectures))
        if ignorable_content is not None:
            _form_params.append(("ignorable_content", ignorable_content))
        if ansible_collection_requirements is not None:
            _form_params.append(
                ("ansible_collection_requirements", ansible_collection_requirements)
            )
        if ansible_collection_auth_url is not None:
            _form_params.append(
                ("ansible_collection_auth_url", ansible_collection_auth_url)
            )
        if ansible_collection_auth_token is not None:
            _form_params.append(
                ("ansible_collection_auth_token", ansible_collection_auth_token)
            )
        if http_proxy_policy is not None:
            _form_params.append(("http_proxy_policy", http_proxy_policy))
        if http_proxy_id is not None:
            _form_params.append(("http_proxy_id", http_proxy_id))
        if arch is not None:
            _form_params.append(("arch", arch))
        if retain_package_versions_count is not None:
            _form_params.append(
                ("retain_package_versions_count", retain_package_versions_count)
            )
        if metadata_expire is not None:
            _form_params.append(("metadata_expire", metadata_expire))
        if excludes is not None:
            _form_params.append(("excludes", excludes))
        if includes is not None:
            _form_params.append(("includes", includes))
        if package_types is not None:
            _form_params.append(("package_types", package_types))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/repositories/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def put_repositories_id_import_uploads(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="Repository id")
        ],
        var_async: Annotated[
            Optional[StrictBool],
            Field(
                description="Do not wait for the ImportUpload action to finish. Default: false"
            ),
        ] = None,
        publish_repository: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to regenerate the repository on disk. Default: true"
            ),
        ] = None,
        sync_capsule: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to sync an external capsule after upload. Default: true"
            ),
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="content type ('deb', 'docker_manifest', 'file', 'ostree_ref', 'rpm', 'srpm')"
            ),
        ] = None,
        uploads: Annotated[
            Optional[List[StrictStr]], Field(description="Array of uploads to import")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Import uploads into a repository


        :param id: Repository id (required)
        :type id: float
        :param var_async: Do not wait for the ImportUpload action to finish. Default: false
        :type var_async: bool
        :param publish_repository: Whether or not to regenerate the repository on disk. Default: true
        :type publish_repository: bool
        :param sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :type sync_capsule: bool
        :param content_type: content type ('deb', 'docker_manifest', 'file', 'ostree_ref', 'rpm', 'srpm')
        :type content_type: str
        :param uploads: Array of uploads to import
        :type uploads: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_import_uploads_serialize(
            id=id,
            var_async=var_async,
            publish_repository=publish_repository,
            sync_capsule=sync_capsule,
            content_type=content_type,
            uploads=uploads,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def put_repositories_id_import_uploads_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="Repository id")
        ],
        var_async: Annotated[
            Optional[StrictBool],
            Field(
                description="Do not wait for the ImportUpload action to finish. Default: false"
            ),
        ] = None,
        publish_repository: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to regenerate the repository on disk. Default: true"
            ),
        ] = None,
        sync_capsule: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to sync an external capsule after upload. Default: true"
            ),
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="content type ('deb', 'docker_manifest', 'file', 'ostree_ref', 'rpm', 'srpm')"
            ),
        ] = None,
        uploads: Annotated[
            Optional[List[StrictStr]], Field(description="Array of uploads to import")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Import uploads into a repository


        :param id: Repository id (required)
        :type id: float
        :param var_async: Do not wait for the ImportUpload action to finish. Default: false
        :type var_async: bool
        :param publish_repository: Whether or not to regenerate the repository on disk. Default: true
        :type publish_repository: bool
        :param sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :type sync_capsule: bool
        :param content_type: content type ('deb', 'docker_manifest', 'file', 'ostree_ref', 'rpm', 'srpm')
        :type content_type: str
        :param uploads: Array of uploads to import
        :type uploads: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_import_uploads_serialize(
            id=id,
            var_async=var_async,
            publish_repository=publish_repository,
            sync_capsule=sync_capsule,
            content_type=content_type,
            uploads=uploads,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def put_repositories_id_import_uploads_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="Repository id")
        ],
        var_async: Annotated[
            Optional[StrictBool],
            Field(
                description="Do not wait for the ImportUpload action to finish. Default: false"
            ),
        ] = None,
        publish_repository: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to regenerate the repository on disk. Default: true"
            ),
        ] = None,
        sync_capsule: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to sync an external capsule after upload. Default: true"
            ),
        ] = None,
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="content type ('deb', 'docker_manifest', 'file', 'ostree_ref', 'rpm', 'srpm')"
            ),
        ] = None,
        uploads: Annotated[
            Optional[List[StrictStr]], Field(description="Array of uploads to import")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Import uploads into a repository


        :param id: Repository id (required)
        :type id: float
        :param var_async: Do not wait for the ImportUpload action to finish. Default: false
        :type var_async: bool
        :param publish_repository: Whether or not to regenerate the repository on disk. Default: true
        :type publish_repository: bool
        :param sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :type sync_capsule: bool
        :param content_type: content type ('deb', 'docker_manifest', 'file', 'ostree_ref', 'rpm', 'srpm')
        :type content_type: str
        :param uploads: Array of uploads to import
        :type uploads: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_import_uploads_serialize(
            id=id,
            var_async=var_async,
            publish_repository=publish_repository,
            sync_capsule=sync_capsule,
            content_type=content_type,
            uploads=uploads,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _put_repositories_id_import_uploads_serialize(
        self,
        id,
        var_async,
        publish_repository,
        sync_capsule,
        content_type,
        uploads,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {
            "uploads": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if var_async is not None:
            _form_params.append(("async", var_async))
        if publish_repository is not None:
            _form_params.append(("publish_repository", publish_repository))
        if sync_capsule is not None:
            _form_params.append(("sync_capsule", sync_capsule))
        if content_type is not None:
            _form_params.append(("content_type", content_type))
        if uploads is not None:
            _form_params.append(("uploads", uploads))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/repositories/{id}/import_uploads",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def put_repositories_id_remove_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        ids: Annotated[
            List[StrictStr], Field(description="Array of content ids to remove")
        ],
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types"
            ),
        ] = None,
        sync_capsule: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to sync an external capsule after upload. Default: true"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """put_repositories_id_remove_content

        Remove content from a repository

        :param id: repository ID (required)
        :type id: float
        :param ids: Array of content ids to remove (required)
        :type ids: List[str]
        :param content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :type content_type: str
        :param sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :type sync_capsule: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_remove_content_serialize(
            id=id,
            ids=ids,
            content_type=content_type,
            sync_capsule=sync_capsule,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def put_repositories_id_remove_content_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        ids: Annotated[
            List[StrictStr], Field(description="Array of content ids to remove")
        ],
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types"
            ),
        ] = None,
        sync_capsule: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to sync an external capsule after upload. Default: true"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """put_repositories_id_remove_content

        Remove content from a repository

        :param id: repository ID (required)
        :type id: float
        :param ids: Array of content ids to remove (required)
        :type ids: List[str]
        :param content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :type content_type: str
        :param sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :type sync_capsule: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_remove_content_serialize(
            id=id,
            ids=ids,
            content_type=content_type,
            sync_capsule=sync_capsule,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def put_repositories_id_remove_content_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        ids: Annotated[
            List[StrictStr], Field(description="Array of content ids to remove")
        ],
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types"
            ),
        ] = None,
        sync_capsule: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to sync an external capsule after upload. Default: true"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_repositories_id_remove_content

        Remove content from a repository

        :param id: repository ID (required)
        :type id: float
        :param ids: Array of content ids to remove (required)
        :type ids: List[str]
        :param content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :type content_type: str
        :param sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :type sync_capsule: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_remove_content_serialize(
            id=id,
            ids=ids,
            content_type=content_type,
            sync_capsule=sync_capsule,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _put_repositories_id_remove_content_serialize(
        self,
        id,
        ids,
        content_type,
        sync_capsule,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {
            "ids": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if ids is not None:
            _form_params.append(("ids", ids))
        if content_type is not None:
            _form_params.append(("content_type", content_type))
        if sync_capsule is not None:
            _form_params.append(("sync_capsule", sync_capsule))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/repositories/{id}/remove_content",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def put_repositories_id_remove_docker_manifests(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        ids: Annotated[
            List[StrictStr], Field(description="Array of content ids to remove")
        ],
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types"
            ),
        ] = None,
        sync_capsule: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to sync an external capsule after upload. Default: true"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """put_repositories_id_remove_docker_manifests

        Remove content from a repository

        :param id: repository ID (required)
        :type id: float
        :param ids: Array of content ids to remove (required)
        :type ids: List[str]
        :param content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :type content_type: str
        :param sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :type sync_capsule: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_remove_docker_manifests_serialize(
            id=id,
            ids=ids,
            content_type=content_type,
            sync_capsule=sync_capsule,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def put_repositories_id_remove_docker_manifests_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        ids: Annotated[
            List[StrictStr], Field(description="Array of content ids to remove")
        ],
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types"
            ),
        ] = None,
        sync_capsule: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to sync an external capsule after upload. Default: true"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """put_repositories_id_remove_docker_manifests

        Remove content from a repository

        :param id: repository ID (required)
        :type id: float
        :param ids: Array of content ids to remove (required)
        :type ids: List[str]
        :param content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :type content_type: str
        :param sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :type sync_capsule: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_remove_docker_manifests_serialize(
            id=id,
            ids=ids,
            content_type=content_type,
            sync_capsule=sync_capsule,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def put_repositories_id_remove_docker_manifests_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        ids: Annotated[
            List[StrictStr], Field(description="Array of content ids to remove")
        ],
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types"
            ),
        ] = None,
        sync_capsule: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to sync an external capsule after upload. Default: true"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_repositories_id_remove_docker_manifests

        Remove content from a repository

        :param id: repository ID (required)
        :type id: float
        :param ids: Array of content ids to remove (required)
        :type ids: List[str]
        :param content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :type content_type: str
        :param sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :type sync_capsule: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_remove_docker_manifests_serialize(
            id=id,
            ids=ids,
            content_type=content_type,
            sync_capsule=sync_capsule,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _put_repositories_id_remove_docker_manifests_serialize(
        self,
        id,
        ids,
        content_type,
        sync_capsule,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {
            "ids": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if ids is not None:
            _form_params.append(("ids", ids))
        if content_type is not None:
            _form_params.append(("content_type", content_type))
        if sync_capsule is not None:
            _form_params.append(("sync_capsule", sync_capsule))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/repositories/{id}/remove_docker_manifests",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def put_repositories_id_remove_packages(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        ids: Annotated[
            List[StrictStr], Field(description="Array of content ids to remove")
        ],
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types"
            ),
        ] = None,
        sync_capsule: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to sync an external capsule after upload. Default: true"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """put_repositories_id_remove_packages

        Remove content from a repository

        :param id: repository ID (required)
        :type id: float
        :param ids: Array of content ids to remove (required)
        :type ids: List[str]
        :param content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :type content_type: str
        :param sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :type sync_capsule: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_remove_packages_serialize(
            id=id,
            ids=ids,
            content_type=content_type,
            sync_capsule=sync_capsule,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def put_repositories_id_remove_packages_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        ids: Annotated[
            List[StrictStr], Field(description="Array of content ids to remove")
        ],
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types"
            ),
        ] = None,
        sync_capsule: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to sync an external capsule after upload. Default: true"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """put_repositories_id_remove_packages

        Remove content from a repository

        :param id: repository ID (required)
        :type id: float
        :param ids: Array of content ids to remove (required)
        :type ids: List[str]
        :param content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :type content_type: str
        :param sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :type sync_capsule: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_remove_packages_serialize(
            id=id,
            ids=ids,
            content_type=content_type,
            sync_capsule=sync_capsule,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def put_repositories_id_remove_packages_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="repository ID")
        ],
        ids: Annotated[
            List[StrictStr], Field(description="Array of content ids to remove")
        ],
        content_type: Annotated[
            Optional[StrictStr],
            Field(
                description="The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types"
            ),
        ] = None,
        sync_capsule: Annotated[
            Optional[StrictBool],
            Field(
                description="Whether or not to sync an external capsule after upload. Default: true"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_repositories_id_remove_packages

        Remove content from a repository

        :param id: repository ID (required)
        :type id: float
        :param ids: Array of content ids to remove (required)
        :type ids: List[str]
        :param content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :type content_type: str
        :param sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :type sync_capsule: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_remove_packages_serialize(
            id=id,
            ids=ids,
            content_type=content_type,
            sync_capsule=sync_capsule,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _put_repositories_id_remove_packages_serialize(
        self,
        id,
        ids,
        content_type,
        sync_capsule,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {
            "ids": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if ids is not None:
            _form_params.append(("ids", ids))
        if content_type is not None:
            _form_params.append(("content_type", content_type))
        if sync_capsule is not None:
            _form_params.append(("sync_capsule", sync_capsule))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/repositories/{id}/remove_packages",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def put_repositories_id_republish(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="Repository identifier")
        ],
        force: Annotated[
            Optional[StrictBool],
            Field(
                description="Force metadata regeneration to proceed. Dangerous when repositories use the 'Complete Mirroring' mirroring policy"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Forces a republish of the specified repository, regenerating metadata and symlinks on the filesystem. Not allowed for repositories with the 'Complete Mirroring' mirroring policy.


        :param id: Repository identifier (required)
        :type id: float
        :param force: Force metadata regeneration to proceed. Dangerous when repositories use the 'Complete Mirroring' mirroring policy
        :type force: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_republish_serialize(
            id=id,
            force=force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def put_repositories_id_republish_with_http_info(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="Repository identifier")
        ],
        force: Annotated[
            Optional[StrictBool],
            Field(
                description="Force metadata regeneration to proceed. Dangerous when repositories use the 'Complete Mirroring' mirroring policy"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Forces a republish of the specified repository, regenerating metadata and symlinks on the filesystem. Not allowed for repositories with the 'Complete Mirroring' mirroring policy.


        :param id: Repository identifier (required)
        :type id: float
        :param force: Force metadata regeneration to proceed. Dangerous when repositories use the 'Complete Mirroring' mirroring policy
        :type force: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_republish_serialize(
            id=id,
            force=force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def put_repositories_id_republish_without_preload_content(
        self,
        id: Annotated[
            Union[StrictFloat, StrictInt], Field(description="Repository identifier")
        ],
        force: Annotated[
            Optional[StrictBool],
            Field(
                description="Force metadata regeneration to proceed. Dangerous when repositories use the 'Complete Mirroring' mirroring policy"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Forces a republish of the specified repository, regenerating metadata and symlinks on the filesystem. Not allowed for repositories with the 'Complete Mirroring' mirroring policy.


        :param id: Repository identifier (required)
        :type id: float
        :param force: Force metadata regeneration to proceed. Dangerous when repositories use the 'Complete Mirroring' mirroring policy
        :type force: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._put_repositories_id_republish_serialize(
            id=id,
            force=force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _put_repositories_id_republish_serialize(
        self,
        id,
        force,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if force is not None:
            _form_params.append(("force", force))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded", "multipart/form-data"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/repositories/{id}/republish",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
