# coding: utf-8

"""
    Foreman (params in:formData)

     <p>Foreman API v2 is currently the default API version.</p>   # noqa: E501

    OpenAPI spec version: v2

    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from pyforeman.api_client import ApiClient


class JobInvocationsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_job_invocations(self, **kwargs):  # noqa: E501
        """List job invocations  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_invocations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param str search: filter results
        :param str order: Sort and order by a searchable field, e.g. '<field> DESC'
        :param float page: Page number, starting at 1
        :param str per_page: Number of results per page to return, 'all' to return all results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_job_invocations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_job_invocations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_job_invocations_with_http_info(self, **kwargs):  # noqa: E501
        """List job invocations  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_invocations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param str search: filter results
        :param str order: Sort and order by a searchable field, e.g. '<field> DESC'
        :param float page: Page number, starting at 1
        :param str per_page: Number of results per page to return, 'all' to return all results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "location_id",
            "organization_id",
            "search",
            "order",
            "page",
            "per_page",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_invocations" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "location_id" in params:
            query_params.append(("location_id", params["location_id"]))  # noqa: E501
        if "organization_id" in params:
            query_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501
        if "search" in params:
            query_params.append(("search", params["search"]))  # noqa: E501
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/job_invocations",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_job_invocations_id(self, id, **kwargs):  # noqa: E501
        """Show job invocation  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_invocations_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param bool host_status: Show Job status for the hosts
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_job_invocations_id_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_job_invocations_id_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def get_job_invocations_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Show job invocation  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_invocations_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param bool host_status: Show Job status for the hosts
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "location_id",
            "organization_id",
            "host_status",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_invocations_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `get_job_invocations_id`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "location_id" in params:
            query_params.append(("location_id", params["location_id"]))  # noqa: E501
        if "organization_id" in params:
            query_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501
        if "host_status" in params:
            query_params.append(("host_status", params["host_status"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/job_invocations/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_job_invocations_id_hosts_host_id(self, id, host_id, **kwargs):  # noqa: E501
        """Get output for a host  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_invocations_id_hosts_host_id(id, host_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str host_id: (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param str since:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_job_invocations_id_hosts_host_id_with_http_info(
                id, host_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_job_invocations_id_hosts_host_id_with_http_info(
                id, host_id, **kwargs
            )  # noqa: E501
            return data

    def get_job_invocations_id_hosts_host_id_with_http_info(
        self, id, host_id, **kwargs
    ):  # noqa: E501
        """Get output for a host  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_invocations_id_hosts_host_id_with_http_info(id, host_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str host_id: (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param str since:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "host_id",
            "location_id",
            "organization_id",
            "since",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_invocations_id_hosts_host_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `get_job_invocations_id_hosts_host_id`"
            )  # noqa: E501
        # verify the required parameter 'host_id' is set
        if self.api_client.client_side_validation and (
            "host_id" not in params or params["host_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `host_id` when calling `get_job_invocations_id_hosts_host_id`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501
        if "host_id" in params:
            path_params["host_id"] = params["host_id"]  # noqa: E501

        query_params = []
        if "location_id" in params:
            query_params.append(("location_id", params["location_id"]))  # noqa: E501
        if "organization_id" in params:
            query_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501
        if "since" in params:
            query_params.append(("since", params["since"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/job_invocations/{id}/hosts/{host_id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_job_invocations_id_hosts_host_id_raw(
        self, id, host_id, **kwargs
    ):  # noqa: E501
        """Get raw output for a host  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_invocations_id_hosts_host_id_raw(id, host_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str host_id: (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_job_invocations_id_hosts_host_id_raw_with_http_info(
                id, host_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_job_invocations_id_hosts_host_id_raw_with_http_info(
                id, host_id, **kwargs
            )  # noqa: E501
            return data

    def get_job_invocations_id_hosts_host_id_raw_with_http_info(
        self, id, host_id, **kwargs
    ):  # noqa: E501
        """Get raw output for a host  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_invocations_id_hosts_host_id_raw_with_http_info(id, host_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str host_id: (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "host_id", "location_id", "organization_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_invocations_id_hosts_host_id_raw" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `get_job_invocations_id_hosts_host_id_raw`"
            )  # noqa: E501
        # verify the required parameter 'host_id' is set
        if self.api_client.client_side_validation and (
            "host_id" not in params or params["host_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `host_id` when calling `get_job_invocations_id_hosts_host_id_raw`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501
        if "host_id" in params:
            path_params["host_id"] = params["host_id"]  # noqa: E501

        query_params = []
        if "location_id" in params:
            query_params.append(("location_id", params["location_id"]))  # noqa: E501
        if "organization_id" in params:
            query_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/job_invocations/{id}/hosts/{host_id}/raw",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_job_invocations_id_outputs(self, id, **kwargs):  # noqa: E501
        """Get outputs of hosts in a job  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_invocations_id_outputs(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param str search_query:
        :param str since:
        :param str raw:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_job_invocations_id_outputs_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_job_invocations_id_outputs_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def get_job_invocations_id_outputs_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get outputs of hosts in a job  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_invocations_id_outputs_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param str search_query:
        :param str since:
        :param str raw:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "location_id",
            "organization_id",
            "search_query",
            "since",
            "raw",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_invocations_id_outputs" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `get_job_invocations_id_outputs`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "location_id" in params:
            query_params.append(("location_id", params["location_id"]))  # noqa: E501
        if "organization_id" in params:
            query_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501
        if "search_query" in params:
            query_params.append(("search_query", params["search_query"]))  # noqa: E501
        if "since" in params:
            query_params.append(("since", params["since"]))  # noqa: E501
        if "raw" in params:
            query_params.append(("raw", params["raw"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/job_invocations/{id}/outputs",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_job_invocations(
        self, job_invocation_targeting_type, **kwargs
    ):  # noqa: E501
        """Create a job invocation  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_job_invocations(job_invocation_targeting_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_invocation_targeting_type: Invocation type, one of {\"static_query\"=>\"Static Query\", \"dynamic_query\"=>\"Dynamic Query\"} (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param str job_invocation_job_template_id: The job template to use, parameter is required unless feature was specified
        :param bool job_invocation_randomized_ordering: Execute the jobs on hosts in randomized order
        :param str job_invocation_ssh_effective_user: What user should be used to run the script (using sudo-like mechanisms). Defaults to a template parameter or global setting.
        :param str job_invocation_ssh_effective_user_password: Set password for effective user (using sudo-like mechanisms)
        :param str job_invocation_ssh_user: Set SSH user
        :param str job_invocation_password: Set SSH password
        :param str job_invocation_key_passphrase: Set SSH key passphrase
        :param str job_invocation_recurrence_cron_line: How often the job should occur, in the cron format
        :param float job_invocation_recurrence_max_iteration: Repeat a maximum of N times
        :param str job_invocation_recurrence_end_time: Perform no more executions after this time
        :param str job_invocation_recurrence_purpose: Designation of a special purpose
        :param str job_invocation_scheduling_start_at: Schedule the job for a future time
        :param str job_invocation_scheduling_start_before: Indicates that the action should be cancelled if it cannot be started before this time.
        :param float job_invocation_concurrency_control_concurrency_level: Run at most N tasks at a time
        :param float job_invocation_bookmark_id:
        :param str job_invocation_search_query:
        :param str job_invocation_description_format: Override the description format from the template for this invocation only
        :param float job_invocation_execution_timeout_interval: Override the timeout interval from the template for this invocation only
        :param str job_invocation_feature: Remote execution feature label that should be triggered, job template assigned to this feature will be used
        :param float job_invocation_time_to_pickup: Override the global time to pickup interval for this invocation only
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_job_invocations_with_http_info(
                job_invocation_targeting_type, **kwargs
            )  # noqa: E501
        else:
            (data) = self.post_job_invocations_with_http_info(
                job_invocation_targeting_type, **kwargs
            )  # noqa: E501
            return data

    def post_job_invocations_with_http_info(
        self, job_invocation_targeting_type, **kwargs
    ):  # noqa: E501
        """Create a job invocation  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_job_invocations_with_http_info(job_invocation_targeting_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_invocation_targeting_type: Invocation type, one of {\"static_query\"=>\"Static Query\", \"dynamic_query\"=>\"Dynamic Query\"} (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param str job_invocation_job_template_id: The job template to use, parameter is required unless feature was specified
        :param bool job_invocation_randomized_ordering: Execute the jobs on hosts in randomized order
        :param str job_invocation_ssh_effective_user: What user should be used to run the script (using sudo-like mechanisms). Defaults to a template parameter or global setting.
        :param str job_invocation_ssh_effective_user_password: Set password for effective user (using sudo-like mechanisms)
        :param str job_invocation_ssh_user: Set SSH user
        :param str job_invocation_password: Set SSH password
        :param str job_invocation_key_passphrase: Set SSH key passphrase
        :param str job_invocation_recurrence_cron_line: How often the job should occur, in the cron format
        :param float job_invocation_recurrence_max_iteration: Repeat a maximum of N times
        :param str job_invocation_recurrence_end_time: Perform no more executions after this time
        :param str job_invocation_recurrence_purpose: Designation of a special purpose
        :param str job_invocation_scheduling_start_at: Schedule the job for a future time
        :param str job_invocation_scheduling_start_before: Indicates that the action should be cancelled if it cannot be started before this time.
        :param float job_invocation_concurrency_control_concurrency_level: Run at most N tasks at a time
        :param float job_invocation_bookmark_id:
        :param str job_invocation_search_query:
        :param str job_invocation_description_format: Override the description format from the template for this invocation only
        :param float job_invocation_execution_timeout_interval: Override the timeout interval from the template for this invocation only
        :param str job_invocation_feature: Remote execution feature label that should be triggered, job template assigned to this feature will be used
        :param float job_invocation_time_to_pickup: Override the global time to pickup interval for this invocation only
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "job_invocation_targeting_type",
            "location_id",
            "organization_id",
            "job_invocation_job_template_id",
            "job_invocation_randomized_ordering",
            "job_invocation_ssh_effective_user",
            "job_invocation_ssh_effective_user_password",
            "job_invocation_ssh_user",
            "job_invocation_password",
            "job_invocation_key_passphrase",
            "job_invocation_recurrence_cron_line",
            "job_invocation_recurrence_max_iteration",
            "job_invocation_recurrence_end_time",
            "job_invocation_recurrence_purpose",
            "job_invocation_scheduling_start_at",
            "job_invocation_scheduling_start_before",
            "job_invocation_concurrency_control_concurrency_level",
            "job_invocation_bookmark_id",
            "job_invocation_search_query",
            "job_invocation_description_format",
            "job_invocation_execution_timeout_interval",
            "job_invocation_feature",
            "job_invocation_time_to_pickup",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_job_invocations" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'job_invocation_targeting_type' is set
        if self.api_client.client_side_validation and (
            "job_invocation_targeting_type" not in params
            or params["job_invocation_targeting_type"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `job_invocation_targeting_type` when calling `post_job_invocations`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "job_invocation_targeting_type" in params:
            form_params.append(
                (
                    "job_invocation[targeting_type]",
                    params["job_invocation_targeting_type"],
                )
            )  # noqa: E501
        if "location_id" in params:
            form_params.append(("location_id", params["location_id"]))  # noqa: E501
        if "organization_id" in params:
            form_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501
        if "job_invocation_job_template_id" in params:
            form_params.append(
                (
                    "job_invocation[job_template_id]",
                    params["job_invocation_job_template_id"],
                )
            )  # noqa: E501
        if "job_invocation_randomized_ordering" in params:
            form_params.append(
                (
                    "job_invocation[randomized_ordering]",
                    params["job_invocation_randomized_ordering"],
                )
            )  # noqa: E501
        if "job_invocation_ssh_effective_user" in params:
            form_params.append(
                (
                    "job_invocation[ssh][effective_user]",
                    params["job_invocation_ssh_effective_user"],
                )
            )  # noqa: E501
        if "job_invocation_ssh_effective_user_password" in params:
            form_params.append(
                (
                    "job_invocation[ssh][effective_user_password]",
                    params["job_invocation_ssh_effective_user_password"],
                )
            )  # noqa: E501
        if "job_invocation_ssh_user" in params:
            form_params.append(
                ("job_invocation[ssh_user]", params["job_invocation_ssh_user"])
            )  # noqa: E501
        if "job_invocation_password" in params:
            form_params.append(
                ("job_invocation[password]", params["job_invocation_password"])
            )  # noqa: E501
        if "job_invocation_key_passphrase" in params:
            form_params.append(
                (
                    "job_invocation[key_passphrase]",
                    params["job_invocation_key_passphrase"],
                )
            )  # noqa: E501
        if "job_invocation_recurrence_cron_line" in params:
            form_params.append(
                (
                    "job_invocation[recurrence][cron_line]",
                    params["job_invocation_recurrence_cron_line"],
                )
            )  # noqa: E501
        if "job_invocation_recurrence_max_iteration" in params:
            form_params.append(
                (
                    "job_invocation[recurrence][max_iteration]",
                    params["job_invocation_recurrence_max_iteration"],
                )
            )  # noqa: E501
        if "job_invocation_recurrence_end_time" in params:
            form_params.append(
                (
                    "job_invocation[recurrence][end_time]",
                    params["job_invocation_recurrence_end_time"],
                )
            )  # noqa: E501
        if "job_invocation_recurrence_purpose" in params:
            form_params.append(
                (
                    "job_invocation[recurrence][purpose]",
                    params["job_invocation_recurrence_purpose"],
                )
            )  # noqa: E501
        if "job_invocation_scheduling_start_at" in params:
            form_params.append(
                (
                    "job_invocation[scheduling][start_at]",
                    params["job_invocation_scheduling_start_at"],
                )
            )  # noqa: E501
        if "job_invocation_scheduling_start_before" in params:
            form_params.append(
                (
                    "job_invocation[scheduling][start_before]",
                    params["job_invocation_scheduling_start_before"],
                )
            )  # noqa: E501
        if "job_invocation_concurrency_control_concurrency_level" in params:
            form_params.append(
                (
                    "job_invocation[concurrency_control][concurrency_level]",
                    params["job_invocation_concurrency_control_concurrency_level"],
                )
            )  # noqa: E501
        if "job_invocation_bookmark_id" in params:
            form_params.append(
                ("job_invocation[bookmark_id]", params["job_invocation_bookmark_id"])
            )  # noqa: E501
        if "job_invocation_search_query" in params:
            form_params.append(
                ("job_invocation[search_query]", params["job_invocation_search_query"])
            )  # noqa: E501
        if "job_invocation_description_format" in params:
            form_params.append(
                (
                    "job_invocation[description_format]",
                    params["job_invocation_description_format"],
                )
            )  # noqa: E501
        if "job_invocation_execution_timeout_interval" in params:
            form_params.append(
                (
                    "job_invocation[execution_timeout_interval]",
                    params["job_invocation_execution_timeout_interval"],
                )
            )  # noqa: E501
        if "job_invocation_feature" in params:
            form_params.append(
                ("job_invocation[feature]", params["job_invocation_feature"])
            )  # noqa: E501
        if "job_invocation_time_to_pickup" in params:
            form_params.append(
                (
                    "job_invocation[time_to_pickup]",
                    params["job_invocation_time_to_pickup"],
                )
            )  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/job_invocations",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_job_invocations_id_cancel(self, id, **kwargs):  # noqa: E501
        """Cancel job invocation  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_job_invocations_id_cancel(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param bool force:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_job_invocations_id_cancel_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.post_job_invocations_id_cancel_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def post_job_invocations_id_cancel_with_http_info(self, id, **kwargs):  # noqa: E501
        """Cancel job invocation  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_job_invocations_id_cancel_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param bool force:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "location_id", "organization_id", "force"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_job_invocations_id_cancel" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `post_job_invocations_id_cancel`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "location_id" in params:
            form_params.append(("location_id", params["location_id"]))  # noqa: E501
        if "organization_id" in params:
            form_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501
        if "force" in params:
            form_params.append(("force", params["force"]))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/job_invocations/{id}/cancel",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_job_invocations_id_rerun(self, id, **kwargs):  # noqa: E501
        """Rerun job on failed hosts  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_job_invocations_id_rerun(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param bool failed_only:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_job_invocations_id_rerun_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.post_job_invocations_id_rerun_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def post_job_invocations_id_rerun_with_http_info(self, id, **kwargs):  # noqa: E501
        """Rerun job on failed hosts  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_job_invocations_id_rerun_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param float location_id: Set the current location context for the request
        :param float organization_id: Set the current organization context for the request
        :param bool failed_only:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "location_id",
            "organization_id",
            "failed_only",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_job_invocations_id_rerun" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `post_job_invocations_id_rerun`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "location_id" in params:
            form_params.append(("location_id", params["location_id"]))  # noqa: E501
        if "organization_id" in params:
            form_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501
        if "failed_only" in params:
            form_params.append(("failed_only", params["failed_only"]))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/job_invocations/{id}/rerun",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
