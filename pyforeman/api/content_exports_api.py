# coding: utf-8

"""
    Foreman (params in:formData)

     <p>Foreman API v2 is currently the default API version.</p>   # noqa: E501

    OpenAPI spec version: v2

    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from pyforeman.api_client import ApiClient


class ContentExportsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_content_exports(self, **kwargs):  # noqa: E501
        """List export histories  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_exports(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float content_view_version_id: Content view version identifier
        :param float content_view_id: Content view identifier
        :param str destination_server: Destination Server name
        :param float organization_id: Organization identifier
        :param float id: Content view version export history identifier
        :param str type: Export Types
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_content_exports_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_content_exports_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_content_exports_with_http_info(self, **kwargs):  # noqa: E501
        """List export histories  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_exports_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float content_view_version_id: Content view version identifier
        :param float content_view_id: Content view identifier
        :param str destination_server: Destination Server name
        :param float organization_id: Organization identifier
        :param float id: Content view version export history identifier
        :param str type: Export Types
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "content_view_version_id",
            "content_view_id",
            "destination_server",
            "organization_id",
            "id",
            "type",
            "search",
            "page",
            "per_page",
            "order",
            "full_result",
            "sort_by",
            "sort_order",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_content_exports" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "content_view_version_id" in params:
            query_params.append(
                ("content_view_version_id", params["content_view_version_id"])
            )  # noqa: E501
        if "content_view_id" in params:
            query_params.append(
                ("content_view_id", params["content_view_id"])
            )  # noqa: E501
        if "destination_server" in params:
            query_params.append(
                ("destination_server", params["destination_server"])
            )  # noqa: E501
        if "organization_id" in params:
            query_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501
        if "id" in params:
            query_params.append(("id", params["id"]))  # noqa: E501
        if "type" in params:
            query_params.append(("type", params["type"]))  # noqa: E501
        if "search" in params:
            query_params.append(("search", params["search"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501
        if "full_result" in params:
            query_params.append(("full_result", params["full_result"]))  # noqa: E501
        if "sort_by" in params:
            query_params.append(("sort_by", params["sort_by"]))  # noqa: E501
        if "sort_order" in params:
            query_params.append(("sort_order", params["sort_order"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/content_exports",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_content_exports_library(self, organization_id, **kwargs):  # noqa: E501
        """Performs a full-export of the repositories in library.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_content_exports_library(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float organization_id: Organization identifier (required)
        :param bool fail_on_missing_content: Fails if any of the repositories belonging to this organization are unexportable. False by default.
        :param str destination_server: Destination Server name
        :param float chunk_size_gb: Split the exported content into archives no greater than the specified size in gigabytes.
        :param str format: Export formats.Choose syncable if the exported content needs to be in a yum format. This option is only available for yum, file repositories. Choose importable if the importing server uses the same version  and exported content needs to be one of yum, file, ansible_collection, docker repositories.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_content_exports_library_with_http_info(
                organization_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.post_content_exports_library_with_http_info(
                organization_id, **kwargs
            )  # noqa: E501
            return data

    def post_content_exports_library_with_http_info(
        self, organization_id, **kwargs
    ):  # noqa: E501
        """Performs a full-export of the repositories in library.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_content_exports_library_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float organization_id: Organization identifier (required)
        :param bool fail_on_missing_content: Fails if any of the repositories belonging to this organization are unexportable. False by default.
        :param str destination_server: Destination Server name
        :param float chunk_size_gb: Split the exported content into archives no greater than the specified size in gigabytes.
        :param str format: Export formats.Choose syncable if the exported content needs to be in a yum format. This option is only available for yum, file repositories. Choose importable if the importing server uses the same version  and exported content needs to be one of yum, file, ansible_collection, docker repositories.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "organization_id",
            "fail_on_missing_content",
            "destination_server",
            "chunk_size_gb",
            "format",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_content_exports_library" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and (
            "organization_id" not in params or params["organization_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `organization_id` when calling `post_content_exports_library`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "organization_id" in params:
            form_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501
        if "fail_on_missing_content" in params:
            form_params.append(
                ("fail_on_missing_content", params["fail_on_missing_content"])
            )  # noqa: E501
        if "destination_server" in params:
            form_params.append(
                ("destination_server", params["destination_server"])
            )  # noqa: E501
        if "chunk_size_gb" in params:
            form_params.append(("chunk_size_gb", params["chunk_size_gb"]))  # noqa: E501
        if "format" in params:
            form_params.append(("format", params["format"]))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/content_exports/library",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_content_exports_repository(self, id, **kwargs):  # noqa: E501
        """Performs a full-export of the repository in library.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_content_exports_repository(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: Repository identifier (required)
        :param float chunk_size_gb: Split the exported content into archives no greater than the specified size in gigabytes.
        :param str format: Export formats.Choose syncable if the exported content needs to be in a yum format. This option is only available for yum, file repositories. Choose importable if the importing server uses the same version  and exported content needs to be one of yum, file, ansible_collection, docker repositories.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_content_exports_repository_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.post_content_exports_repository_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def post_content_exports_repository_with_http_info(
        self, id, **kwargs
    ):  # noqa: E501
        """Performs a full-export of the repository in library.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_content_exports_repository_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: Repository identifier (required)
        :param float chunk_size_gb: Split the exported content into archives no greater than the specified size in gigabytes.
        :param str format: Export formats.Choose syncable if the exported content needs to be in a yum format. This option is only available for yum, file repositories. Choose importable if the importing server uses the same version  and exported content needs to be one of yum, file, ansible_collection, docker repositories.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "chunk_size_gb", "format"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_content_exports_repository" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `post_content_exports_repository`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "id" in params:
            form_params.append(("id", params["id"]))  # noqa: E501
        if "chunk_size_gb" in params:
            form_params.append(("chunk_size_gb", params["chunk_size_gb"]))  # noqa: E501
        if "format" in params:
            form_params.append(("format", params["format"]))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/content_exports/repository",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_content_exports_version(self, id, **kwargs):  # noqa: E501
        """Performs a full-export of a content view version.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_content_exports_version(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: Content view version identifier (required)
        :param bool fail_on_missing_content: Fails if any of the repositories belonging to this version are unexportable. False by default.
        :param str destination_server: Destination Server name
        :param float chunk_size_gb: Split the exported content into archives no greater than the specified size in gigabytes.
        :param str format: Export formats.Choose syncable if the exported content needs to be in a yum format. This option is only available for yum, file repositories. Choose importable if the importing server uses the same version  and exported content needs to be one of yum, file, ansible_collection, docker repositories.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_content_exports_version_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.post_content_exports_version_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def post_content_exports_version_with_http_info(self, id, **kwargs):  # noqa: E501
        """Performs a full-export of a content view version.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_content_exports_version_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: Content view version identifier (required)
        :param bool fail_on_missing_content: Fails if any of the repositories belonging to this version are unexportable. False by default.
        :param str destination_server: Destination Server name
        :param float chunk_size_gb: Split the exported content into archives no greater than the specified size in gigabytes.
        :param str format: Export formats.Choose syncable if the exported content needs to be in a yum format. This option is only available for yum, file repositories. Choose importable if the importing server uses the same version  and exported content needs to be one of yum, file, ansible_collection, docker repositories.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "fail_on_missing_content",
            "destination_server",
            "chunk_size_gb",
            "format",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_content_exports_version" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `post_content_exports_version`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "id" in params:
            form_params.append(("id", params["id"]))  # noqa: E501
        if "fail_on_missing_content" in params:
            form_params.append(
                ("fail_on_missing_content", params["fail_on_missing_content"])
            )  # noqa: E501
        if "destination_server" in params:
            form_params.append(
                ("destination_server", params["destination_server"])
            )  # noqa: E501
        if "chunk_size_gb" in params:
            form_params.append(("chunk_size_gb", params["chunk_size_gb"]))  # noqa: E501
        if "format" in params:
            form_params.append(("format", params["format"]))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/content_exports/version",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
