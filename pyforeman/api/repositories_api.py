# coding: utf-8

"""
    Foreman (params in:formData)

     <p>Foreman API v2 is currently the default API version.</p>   # noqa: E501

    OpenAPI spec version: v2

    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from pyforeman.api_client import ApiClient


class RepositoriesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_repositories_id(self, id, **kwargs):  # noqa: E501
        """Destroy a custom repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repositories_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: (required)
        :param bool remove_from_content_view_versions: Force delete the repository by removing it from all content view versions
        :param bool delete_empty_repo_filters: Delete content view filters that have this repository as the last associated repository. Defaults to true. If false, such filters will now apply to all repositories in the content view.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.delete_repositories_id_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.delete_repositories_id_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def delete_repositories_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Destroy a custom repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repositories_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: (required)
        :param bool remove_from_content_view_versions: Force delete the repository by removing it from all content view versions
        :param bool delete_empty_repo_filters: Delete content view filters that have this repository as the last associated repository. Defaults to true. If false, such filters will now apply to all repositories in the content view.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "remove_from_content_view_versions",
            "delete_empty_repo_filters",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_repositories_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `delete_repositories_id`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "remove_from_content_view_versions" in params:
            form_params.append(
                (
                    "remove_from_content_view_versions",
                    params["remove_from_content_view_versions"],
                )
            )  # noqa: E501
        if "delete_empty_repo_filters" in params:
            form_params.append(
                ("delete_empty_repo_filters", params["delete_empty_repo_filters"])
            )  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/{id}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_content_types(self, **kwargs):  # noqa: E501
        """Return the enabled content types  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_types(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_content_types_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_content_types_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_content_types_with_http_info(self, **kwargs):  # noqa: E501
        """Return the enabled content types  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_types_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_content_types" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/content_types",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_content_views_id_repositories(
        self, id, organization_id, product_id, environment_id, **kwargs
    ):  # noqa: E501
        """List of repositories for a content view  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_views_id_repositories(id, organization_id, product_id, environment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: (required)
        :param float organization_id: ID of an organization to show repositories in (required)
        :param float product_id: ID of a product to show repositories of (required)
        :param float environment_id: ID of an environment to show repositories in (required)
        :param float content_view_id: ID of a content view to show repositories in
        :param float content_view_version_id: ID of a content view version to show repositories in
        :param str deb_id: Id of a deb package to find repositories that contain the deb
        :param str erratum_id: Id of an erratum to find repositories that contain the erratum
        :param str rpm_id: Id of a rpm package to find repositories that contain the rpm
        :param str file_id: Id of a file to find repositories that contain the file
        :param str ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :param bool library: show repositories in Library and the default content view
        :param bool archived: show archived repositories
        :param str content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :param str name: name of the repository
        :param str label: label of the repository
        :param str description: description of the repository
        :param str available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :param str with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :param str download_policy: limit to only repositories with this download policy
        :param str username: only show the repositories readable by this user with this username
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_content_views_id_repositories_with_http_info(
                id, organization_id, product_id, environment_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_content_views_id_repositories_with_http_info(
                id, organization_id, product_id, environment_id, **kwargs
            )  # noqa: E501
            return data

    def get_content_views_id_repositories_with_http_info(
        self, id, organization_id, product_id, environment_id, **kwargs
    ):  # noqa: E501
        """List of repositories for a content view  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_content_views_id_repositories_with_http_info(id, organization_id, product_id, environment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: (required)
        :param float organization_id: ID of an organization to show repositories in (required)
        :param float product_id: ID of a product to show repositories of (required)
        :param float environment_id: ID of an environment to show repositories in (required)
        :param float content_view_id: ID of a content view to show repositories in
        :param float content_view_version_id: ID of a content view version to show repositories in
        :param str deb_id: Id of a deb package to find repositories that contain the deb
        :param str erratum_id: Id of an erratum to find repositories that contain the erratum
        :param str rpm_id: Id of a rpm package to find repositories that contain the rpm
        :param str file_id: Id of a file to find repositories that contain the file
        :param str ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :param bool library: show repositories in Library and the default content view
        :param bool archived: show archived repositories
        :param str content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :param str name: name of the repository
        :param str label: label of the repository
        :param str description: description of the repository
        :param str available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :param str with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :param str download_policy: limit to only repositories with this download policy
        :param str username: only show the repositories readable by this user with this username
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "organization_id",
            "product_id",
            "environment_id",
            "content_view_id",
            "content_view_version_id",
            "deb_id",
            "erratum_id",
            "rpm_id",
            "file_id",
            "ansible_collection_id",
            "library",
            "archived",
            "content_type",
            "name",
            "label",
            "description",
            "available_for",
            "with_content",
            "download_policy",
            "username",
            "search",
            "page",
            "per_page",
            "order",
            "full_result",
            "sort_by",
            "sort_order",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_content_views_id_repositories" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `get_content_views_id_repositories`"
            )  # noqa: E501
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and (
            "organization_id" not in params or params["organization_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `organization_id` when calling `get_content_views_id_repositories`"
            )  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and (
            "product_id" not in params or params["product_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `product_id` when calling `get_content_views_id_repositories`"
            )  # noqa: E501
        # verify the required parameter 'environment_id' is set
        if self.api_client.client_side_validation and (
            "environment_id" not in params or params["environment_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `environment_id` when calling `get_content_views_id_repositories`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "organization_id" in params:
            query_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501
        if "product_id" in params:
            query_params.append(("product_id", params["product_id"]))  # noqa: E501
        if "environment_id" in params:
            query_params.append(
                ("environment_id", params["environment_id"])
            )  # noqa: E501
        if "content_view_id" in params:
            query_params.append(
                ("content_view_id", params["content_view_id"])
            )  # noqa: E501
        if "content_view_version_id" in params:
            query_params.append(
                ("content_view_version_id", params["content_view_version_id"])
            )  # noqa: E501
        if "deb_id" in params:
            query_params.append(("deb_id", params["deb_id"]))  # noqa: E501
        if "erratum_id" in params:
            query_params.append(("erratum_id", params["erratum_id"]))  # noqa: E501
        if "rpm_id" in params:
            query_params.append(("rpm_id", params["rpm_id"]))  # noqa: E501
        if "file_id" in params:
            query_params.append(("file_id", params["file_id"]))  # noqa: E501
        if "ansible_collection_id" in params:
            query_params.append(
                ("ansible_collection_id", params["ansible_collection_id"])
            )  # noqa: E501
        if "library" in params:
            query_params.append(("library", params["library"]))  # noqa: E501
        if "archived" in params:
            query_params.append(("archived", params["archived"]))  # noqa: E501
        if "content_type" in params:
            query_params.append(("content_type", params["content_type"]))  # noqa: E501
        if "name" in params:
            query_params.append(("name", params["name"]))  # noqa: E501
        if "label" in params:
            query_params.append(("label", params["label"]))  # noqa: E501
        if "description" in params:
            query_params.append(("description", params["description"]))  # noqa: E501
        if "available_for" in params:
            query_params.append(
                ("available_for", params["available_for"])
            )  # noqa: E501
        if "with_content" in params:
            query_params.append(("with_content", params["with_content"]))  # noqa: E501
        if "download_policy" in params:
            query_params.append(
                ("download_policy", params["download_policy"])
            )  # noqa: E501
        if "username" in params:
            query_params.append(("username", params["username"]))  # noqa: E501
        if "search" in params:
            query_params.append(("search", params["search"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501
        if "full_result" in params:
            query_params.append(("full_result", params["full_result"]))  # noqa: E501
        if "sort_by" in params:
            query_params.append(("sort_by", params["sort_by"]))  # noqa: E501
        if "sort_order" in params:
            query_params.append(("sort_order", params["sort_order"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/content_views/{id}/repositories",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_environments_environment_id_products_product_id_repositories(
        self, product_id, environment_id, organization_id, **kwargs
    ):  # noqa: E501
        """List of repositories belonging to a product in an environment  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_environments_environment_id_products_product_id_repositories(product_id, environment_id, organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float product_id: ID of a product to show repositories of (required)
        :param float environment_id: ID of an environment to show repositories in (required)
        :param float organization_id: ID of an organization to show repositories in (required)
        :param float content_view_id: ID of a content view to show repositories in
        :param float content_view_version_id: ID of a content view version to show repositories in
        :param str deb_id: Id of a deb package to find repositories that contain the deb
        :param str erratum_id: Id of an erratum to find repositories that contain the erratum
        :param str rpm_id: Id of a rpm package to find repositories that contain the rpm
        :param str file_id: Id of a file to find repositories that contain the file
        :param str ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :param bool library: show repositories in Library and the default content view
        :param bool archived: show archived repositories
        :param str content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :param str name: name of the repository
        :param str label: label of the repository
        :param str description: description of the repository
        :param str available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :param str with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :param str download_policy: limit to only repositories with this download policy
        :param str username: only show the repositories readable by this user with this username
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_environments_environment_id_products_product_id_repositories_with_http_info(
                product_id, environment_id, organization_id, **kwargs
            )  # noqa: E501
        else:
            (
                data
            ) = self.get_environments_environment_id_products_product_id_repositories_with_http_info(
                product_id, environment_id, organization_id, **kwargs
            )  # noqa: E501
            return data

    def get_environments_environment_id_products_product_id_repositories_with_http_info(
        self, product_id, environment_id, organization_id, **kwargs
    ):  # noqa: E501
        """List of repositories belonging to a product in an environment  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_environments_environment_id_products_product_id_repositories_with_http_info(product_id, environment_id, organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float product_id: ID of a product to show repositories of (required)
        :param float environment_id: ID of an environment to show repositories in (required)
        :param float organization_id: ID of an organization to show repositories in (required)
        :param float content_view_id: ID of a content view to show repositories in
        :param float content_view_version_id: ID of a content view version to show repositories in
        :param str deb_id: Id of a deb package to find repositories that contain the deb
        :param str erratum_id: Id of an erratum to find repositories that contain the erratum
        :param str rpm_id: Id of a rpm package to find repositories that contain the rpm
        :param str file_id: Id of a file to find repositories that contain the file
        :param str ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :param bool library: show repositories in Library and the default content view
        :param bool archived: show archived repositories
        :param str content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :param str name: name of the repository
        :param str label: label of the repository
        :param str description: description of the repository
        :param str available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :param str with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :param str download_policy: limit to only repositories with this download policy
        :param str username: only show the repositories readable by this user with this username
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "product_id",
            "environment_id",
            "organization_id",
            "content_view_id",
            "content_view_version_id",
            "deb_id",
            "erratum_id",
            "rpm_id",
            "file_id",
            "ansible_collection_id",
            "library",
            "archived",
            "content_type",
            "name",
            "label",
            "description",
            "available_for",
            "with_content",
            "download_policy",
            "username",
            "search",
            "page",
            "per_page",
            "order",
            "full_result",
            "sort_by",
            "sort_order",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_environments_environment_id_products_product_id_repositories"
                    % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and (
            "product_id" not in params or params["product_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `product_id` when calling `get_environments_environment_id_products_product_id_repositories`"
            )  # noqa: E501
        # verify the required parameter 'environment_id' is set
        if self.api_client.client_side_validation and (
            "environment_id" not in params or params["environment_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `environment_id` when calling `get_environments_environment_id_products_product_id_repositories`"
            )  # noqa: E501
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and (
            "organization_id" not in params or params["organization_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `organization_id` when calling `get_environments_environment_id_products_product_id_repositories`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "product_id" in params:
            path_params["product_id"] = params["product_id"]  # noqa: E501
        if "environment_id" in params:
            path_params["environment_id"] = params["environment_id"]  # noqa: E501

        query_params = []
        if "organization_id" in params:
            query_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501
        if "content_view_id" in params:
            query_params.append(
                ("content_view_id", params["content_view_id"])
            )  # noqa: E501
        if "content_view_version_id" in params:
            query_params.append(
                ("content_view_version_id", params["content_view_version_id"])
            )  # noqa: E501
        if "deb_id" in params:
            query_params.append(("deb_id", params["deb_id"]))  # noqa: E501
        if "erratum_id" in params:
            query_params.append(("erratum_id", params["erratum_id"]))  # noqa: E501
        if "rpm_id" in params:
            query_params.append(("rpm_id", params["rpm_id"]))  # noqa: E501
        if "file_id" in params:
            query_params.append(("file_id", params["file_id"]))  # noqa: E501
        if "ansible_collection_id" in params:
            query_params.append(
                ("ansible_collection_id", params["ansible_collection_id"])
            )  # noqa: E501
        if "library" in params:
            query_params.append(("library", params["library"]))  # noqa: E501
        if "archived" in params:
            query_params.append(("archived", params["archived"]))  # noqa: E501
        if "content_type" in params:
            query_params.append(("content_type", params["content_type"]))  # noqa: E501
        if "name" in params:
            query_params.append(("name", params["name"]))  # noqa: E501
        if "label" in params:
            query_params.append(("label", params["label"]))  # noqa: E501
        if "description" in params:
            query_params.append(("description", params["description"]))  # noqa: E501
        if "available_for" in params:
            query_params.append(
                ("available_for", params["available_for"])
            )  # noqa: E501
        if "with_content" in params:
            query_params.append(("with_content", params["with_content"]))  # noqa: E501
        if "download_policy" in params:
            query_params.append(
                ("download_policy", params["download_policy"])
            )  # noqa: E501
        if "username" in params:
            query_params.append(("username", params["username"]))  # noqa: E501
        if "search" in params:
            query_params.append(("search", params["search"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501
        if "full_result" in params:
            query_params.append(("full_result", params["full_result"]))  # noqa: E501
        if "sort_by" in params:
            query_params.append(("sort_by", params["sort_by"]))  # noqa: E501
        if "sort_order" in params:
            query_params.append(("sort_order", params["sort_order"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/environments/{environment_id}/products/{product_id}/repositories",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_organizations_organization_id_environments_environment_id_repositories(
        self, organization_id, environment_id, product_id, **kwargs
    ):  # noqa: E501
        """List repositories in the environment  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organizations_organization_id_environments_environment_id_repositories(organization_id, environment_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float organization_id: ID of an organization to show repositories in (required)
        :param float environment_id: ID of an environment to show repositories in (required)
        :param float product_id: ID of a product to show repositories of (required)
        :param float content_view_id: ID of a content view to show repositories in
        :param float content_view_version_id: ID of a content view version to show repositories in
        :param str deb_id: Id of a deb package to find repositories that contain the deb
        :param str erratum_id: Id of an erratum to find repositories that contain the erratum
        :param str rpm_id: Id of a rpm package to find repositories that contain the rpm
        :param str file_id: Id of a file to find repositories that contain the file
        :param str ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :param bool library: show repositories in Library and the default content view
        :param bool archived: show archived repositories
        :param str content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :param str name: name of the repository
        :param str label: label of the repository
        :param str description: description of the repository
        :param str available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :param str with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :param str download_policy: limit to only repositories with this download policy
        :param str username: only show the repositories readable by this user with this username
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_organizations_organization_id_environments_environment_id_repositories_with_http_info(
                organization_id, environment_id, product_id, **kwargs
            )  # noqa: E501
        else:
            (
                data
            ) = self.get_organizations_organization_id_environments_environment_id_repositories_with_http_info(
                organization_id, environment_id, product_id, **kwargs
            )  # noqa: E501
            return data

    def get_organizations_organization_id_environments_environment_id_repositories_with_http_info(
        self, organization_id, environment_id, product_id, **kwargs
    ):  # noqa: E501
        """List repositories in the environment  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organizations_organization_id_environments_environment_id_repositories_with_http_info(organization_id, environment_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float organization_id: ID of an organization to show repositories in (required)
        :param float environment_id: ID of an environment to show repositories in (required)
        :param float product_id: ID of a product to show repositories of (required)
        :param float content_view_id: ID of a content view to show repositories in
        :param float content_view_version_id: ID of a content view version to show repositories in
        :param str deb_id: Id of a deb package to find repositories that contain the deb
        :param str erratum_id: Id of an erratum to find repositories that contain the erratum
        :param str rpm_id: Id of a rpm package to find repositories that contain the rpm
        :param str file_id: Id of a file to find repositories that contain the file
        :param str ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :param bool library: show repositories in Library and the default content view
        :param bool archived: show archived repositories
        :param str content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :param str name: name of the repository
        :param str label: label of the repository
        :param str description: description of the repository
        :param str available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :param str with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :param str download_policy: limit to only repositories with this download policy
        :param str username: only show the repositories readable by this user with this username
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "organization_id",
            "environment_id",
            "product_id",
            "content_view_id",
            "content_view_version_id",
            "deb_id",
            "erratum_id",
            "rpm_id",
            "file_id",
            "ansible_collection_id",
            "library",
            "archived",
            "content_type",
            "name",
            "label",
            "description",
            "available_for",
            "with_content",
            "download_policy",
            "username",
            "search",
            "page",
            "per_page",
            "order",
            "full_result",
            "sort_by",
            "sort_order",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organizations_organization_id_environments_environment_id_repositories"
                    % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and (
            "organization_id" not in params or params["organization_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `organization_id` when calling `get_organizations_organization_id_environments_environment_id_repositories`"
            )  # noqa: E501
        # verify the required parameter 'environment_id' is set
        if self.api_client.client_side_validation and (
            "environment_id" not in params or params["environment_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `environment_id` when calling `get_organizations_organization_id_environments_environment_id_repositories`"
            )  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and (
            "product_id" not in params or params["product_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `product_id` when calling `get_organizations_organization_id_environments_environment_id_repositories`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "organization_id" in params:
            path_params["organization_id"] = params["organization_id"]  # noqa: E501
        if "environment_id" in params:
            path_params["environment_id"] = params["environment_id"]  # noqa: E501

        query_params = []
        if "product_id" in params:
            query_params.append(("product_id", params["product_id"]))  # noqa: E501
        if "content_view_id" in params:
            query_params.append(
                ("content_view_id", params["content_view_id"])
            )  # noqa: E501
        if "content_view_version_id" in params:
            query_params.append(
                ("content_view_version_id", params["content_view_version_id"])
            )  # noqa: E501
        if "deb_id" in params:
            query_params.append(("deb_id", params["deb_id"]))  # noqa: E501
        if "erratum_id" in params:
            query_params.append(("erratum_id", params["erratum_id"]))  # noqa: E501
        if "rpm_id" in params:
            query_params.append(("rpm_id", params["rpm_id"]))  # noqa: E501
        if "file_id" in params:
            query_params.append(("file_id", params["file_id"]))  # noqa: E501
        if "ansible_collection_id" in params:
            query_params.append(
                ("ansible_collection_id", params["ansible_collection_id"])
            )  # noqa: E501
        if "library" in params:
            query_params.append(("library", params["library"]))  # noqa: E501
        if "archived" in params:
            query_params.append(("archived", params["archived"]))  # noqa: E501
        if "content_type" in params:
            query_params.append(("content_type", params["content_type"]))  # noqa: E501
        if "name" in params:
            query_params.append(("name", params["name"]))  # noqa: E501
        if "label" in params:
            query_params.append(("label", params["label"]))  # noqa: E501
        if "description" in params:
            query_params.append(("description", params["description"]))  # noqa: E501
        if "available_for" in params:
            query_params.append(
                ("available_for", params["available_for"])
            )  # noqa: E501
        if "with_content" in params:
            query_params.append(("with_content", params["with_content"]))  # noqa: E501
        if "download_policy" in params:
            query_params.append(
                ("download_policy", params["download_policy"])
            )  # noqa: E501
        if "username" in params:
            query_params.append(("username", params["username"]))  # noqa: E501
        if "search" in params:
            query_params.append(("search", params["search"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501
        if "full_result" in params:
            query_params.append(("full_result", params["full_result"]))  # noqa: E501
        if "sort_by" in params:
            query_params.append(("sort_by", params["sort_by"]))  # noqa: E501
        if "sort_order" in params:
            query_params.append(("sort_order", params["sort_order"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/organizations/{organization_id}/environments/{environment_id}/repositories",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_organizations_organization_id_repositories(
        self, organization_id, product_id, environment_id, **kwargs
    ):  # noqa: E501
        """List of repositories in an organization  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organizations_organization_id_repositories(organization_id, product_id, environment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float organization_id: ID of an organization to show repositories in (required)
        :param float product_id: ID of a product to show repositories of (required)
        :param float environment_id: ID of an environment to show repositories in (required)
        :param float content_view_id: ID of a content view to show repositories in
        :param float content_view_version_id: ID of a content view version to show repositories in
        :param str deb_id: Id of a deb package to find repositories that contain the deb
        :param str erratum_id: Id of an erratum to find repositories that contain the erratum
        :param str rpm_id: Id of a rpm package to find repositories that contain the rpm
        :param str file_id: Id of a file to find repositories that contain the file
        :param str ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :param bool library: show repositories in Library and the default content view
        :param bool archived: show archived repositories
        :param str content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :param str name: name of the repository
        :param str label: label of the repository
        :param str description: description of the repository
        :param str available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :param str with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :param str download_policy: limit to only repositories with this download policy
        :param str username: only show the repositories readable by this user with this username
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_organizations_organization_id_repositories_with_http_info(
                organization_id, product_id, environment_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_organizations_organization_id_repositories_with_http_info(
                organization_id, product_id, environment_id, **kwargs
            )  # noqa: E501
            return data

    def get_organizations_organization_id_repositories_with_http_info(
        self, organization_id, product_id, environment_id, **kwargs
    ):  # noqa: E501
        """List of repositories in an organization  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organizations_organization_id_repositories_with_http_info(organization_id, product_id, environment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float organization_id: ID of an organization to show repositories in (required)
        :param float product_id: ID of a product to show repositories of (required)
        :param float environment_id: ID of an environment to show repositories in (required)
        :param float content_view_id: ID of a content view to show repositories in
        :param float content_view_version_id: ID of a content view version to show repositories in
        :param str deb_id: Id of a deb package to find repositories that contain the deb
        :param str erratum_id: Id of an erratum to find repositories that contain the erratum
        :param str rpm_id: Id of a rpm package to find repositories that contain the rpm
        :param str file_id: Id of a file to find repositories that contain the file
        :param str ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :param bool library: show repositories in Library and the default content view
        :param bool archived: show archived repositories
        :param str content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :param str name: name of the repository
        :param str label: label of the repository
        :param str description: description of the repository
        :param str available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :param str with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :param str download_policy: limit to only repositories with this download policy
        :param str username: only show the repositories readable by this user with this username
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "organization_id",
            "product_id",
            "environment_id",
            "content_view_id",
            "content_view_version_id",
            "deb_id",
            "erratum_id",
            "rpm_id",
            "file_id",
            "ansible_collection_id",
            "library",
            "archived",
            "content_type",
            "name",
            "label",
            "description",
            "available_for",
            "with_content",
            "download_policy",
            "username",
            "search",
            "page",
            "per_page",
            "order",
            "full_result",
            "sort_by",
            "sort_order",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organizations_organization_id_repositories" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and (
            "organization_id" not in params or params["organization_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `organization_id` when calling `get_organizations_organization_id_repositories`"
            )  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and (
            "product_id" not in params or params["product_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `product_id` when calling `get_organizations_organization_id_repositories`"
            )  # noqa: E501
        # verify the required parameter 'environment_id' is set
        if self.api_client.client_side_validation and (
            "environment_id" not in params or params["environment_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `environment_id` when calling `get_organizations_organization_id_repositories`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "organization_id" in params:
            path_params["organization_id"] = params["organization_id"]  # noqa: E501

        query_params = []
        if "product_id" in params:
            query_params.append(("product_id", params["product_id"]))  # noqa: E501
        if "environment_id" in params:
            query_params.append(
                ("environment_id", params["environment_id"])
            )  # noqa: E501
        if "content_view_id" in params:
            query_params.append(
                ("content_view_id", params["content_view_id"])
            )  # noqa: E501
        if "content_view_version_id" in params:
            query_params.append(
                ("content_view_version_id", params["content_view_version_id"])
            )  # noqa: E501
        if "deb_id" in params:
            query_params.append(("deb_id", params["deb_id"]))  # noqa: E501
        if "erratum_id" in params:
            query_params.append(("erratum_id", params["erratum_id"]))  # noqa: E501
        if "rpm_id" in params:
            query_params.append(("rpm_id", params["rpm_id"]))  # noqa: E501
        if "file_id" in params:
            query_params.append(("file_id", params["file_id"]))  # noqa: E501
        if "ansible_collection_id" in params:
            query_params.append(
                ("ansible_collection_id", params["ansible_collection_id"])
            )  # noqa: E501
        if "library" in params:
            query_params.append(("library", params["library"]))  # noqa: E501
        if "archived" in params:
            query_params.append(("archived", params["archived"]))  # noqa: E501
        if "content_type" in params:
            query_params.append(("content_type", params["content_type"]))  # noqa: E501
        if "name" in params:
            query_params.append(("name", params["name"]))  # noqa: E501
        if "label" in params:
            query_params.append(("label", params["label"]))  # noqa: E501
        if "description" in params:
            query_params.append(("description", params["description"]))  # noqa: E501
        if "available_for" in params:
            query_params.append(
                ("available_for", params["available_for"])
            )  # noqa: E501
        if "with_content" in params:
            query_params.append(("with_content", params["with_content"]))  # noqa: E501
        if "download_policy" in params:
            query_params.append(
                ("download_policy", params["download_policy"])
            )  # noqa: E501
        if "username" in params:
            query_params.append(("username", params["username"]))  # noqa: E501
        if "search" in params:
            query_params.append(("search", params["search"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501
        if "full_result" in params:
            query_params.append(("full_result", params["full_result"]))  # noqa: E501
        if "sort_by" in params:
            query_params.append(("sort_by", params["sort_by"]))  # noqa: E501
        if "sort_order" in params:
            query_params.append(("sort_order", params["sort_order"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/organizations/{organization_id}/repositories",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_products_product_id_repositories(
        self, product_id, organization_id, environment_id, **kwargs
    ):  # noqa: E501
        """List of repositories for a product  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_products_product_id_repositories(product_id, organization_id, environment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float product_id: ID of a product to show repositories of (required)
        :param float organization_id: ID of an organization to show repositories in (required)
        :param float environment_id: ID of an environment to show repositories in (required)
        :param float content_view_id: ID of a content view to show repositories in
        :param float content_view_version_id: ID of a content view version to show repositories in
        :param str deb_id: Id of a deb package to find repositories that contain the deb
        :param str erratum_id: Id of an erratum to find repositories that contain the erratum
        :param str rpm_id: Id of a rpm package to find repositories that contain the rpm
        :param str file_id: Id of a file to find repositories that contain the file
        :param str ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :param bool library: show repositories in Library and the default content view
        :param bool archived: show archived repositories
        :param str content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :param str name: name of the repository
        :param str label: label of the repository
        :param str description: description of the repository
        :param str available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :param str with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :param str download_policy: limit to only repositories with this download policy
        :param str username: only show the repositories readable by this user with this username
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_products_product_id_repositories_with_http_info(
                product_id, organization_id, environment_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_products_product_id_repositories_with_http_info(
                product_id, organization_id, environment_id, **kwargs
            )  # noqa: E501
            return data

    def get_products_product_id_repositories_with_http_info(
        self, product_id, organization_id, environment_id, **kwargs
    ):  # noqa: E501
        """List of repositories for a product  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_products_product_id_repositories_with_http_info(product_id, organization_id, environment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float product_id: ID of a product to show repositories of (required)
        :param float organization_id: ID of an organization to show repositories in (required)
        :param float environment_id: ID of an environment to show repositories in (required)
        :param float content_view_id: ID of a content view to show repositories in
        :param float content_view_version_id: ID of a content view version to show repositories in
        :param str deb_id: Id of a deb package to find repositories that contain the deb
        :param str erratum_id: Id of an erratum to find repositories that contain the erratum
        :param str rpm_id: Id of a rpm package to find repositories that contain the rpm
        :param str file_id: Id of a file to find repositories that contain the file
        :param str ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :param bool library: show repositories in Library and the default content view
        :param bool archived: show archived repositories
        :param str content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :param str name: name of the repository
        :param str label: label of the repository
        :param str description: description of the repository
        :param str available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :param str with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :param str download_policy: limit to only repositories with this download policy
        :param str username: only show the repositories readable by this user with this username
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "product_id",
            "organization_id",
            "environment_id",
            "content_view_id",
            "content_view_version_id",
            "deb_id",
            "erratum_id",
            "rpm_id",
            "file_id",
            "ansible_collection_id",
            "library",
            "archived",
            "content_type",
            "name",
            "label",
            "description",
            "available_for",
            "with_content",
            "download_policy",
            "username",
            "search",
            "page",
            "per_page",
            "order",
            "full_result",
            "sort_by",
            "sort_order",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_products_product_id_repositories" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and (
            "product_id" not in params or params["product_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `product_id` when calling `get_products_product_id_repositories`"
            )  # noqa: E501
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and (
            "organization_id" not in params or params["organization_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `organization_id` when calling `get_products_product_id_repositories`"
            )  # noqa: E501
        # verify the required parameter 'environment_id' is set
        if self.api_client.client_side_validation and (
            "environment_id" not in params or params["environment_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `environment_id` when calling `get_products_product_id_repositories`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "product_id" in params:
            path_params["product_id"] = params["product_id"]  # noqa: E501

        query_params = []
        if "organization_id" in params:
            query_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501
        if "environment_id" in params:
            query_params.append(
                ("environment_id", params["environment_id"])
            )  # noqa: E501
        if "content_view_id" in params:
            query_params.append(
                ("content_view_id", params["content_view_id"])
            )  # noqa: E501
        if "content_view_version_id" in params:
            query_params.append(
                ("content_view_version_id", params["content_view_version_id"])
            )  # noqa: E501
        if "deb_id" in params:
            query_params.append(("deb_id", params["deb_id"]))  # noqa: E501
        if "erratum_id" in params:
            query_params.append(("erratum_id", params["erratum_id"]))  # noqa: E501
        if "rpm_id" in params:
            query_params.append(("rpm_id", params["rpm_id"]))  # noqa: E501
        if "file_id" in params:
            query_params.append(("file_id", params["file_id"]))  # noqa: E501
        if "ansible_collection_id" in params:
            query_params.append(
                ("ansible_collection_id", params["ansible_collection_id"])
            )  # noqa: E501
        if "library" in params:
            query_params.append(("library", params["library"]))  # noqa: E501
        if "archived" in params:
            query_params.append(("archived", params["archived"]))  # noqa: E501
        if "content_type" in params:
            query_params.append(("content_type", params["content_type"]))  # noqa: E501
        if "name" in params:
            query_params.append(("name", params["name"]))  # noqa: E501
        if "label" in params:
            query_params.append(("label", params["label"]))  # noqa: E501
        if "description" in params:
            query_params.append(("description", params["description"]))  # noqa: E501
        if "available_for" in params:
            query_params.append(
                ("available_for", params["available_for"])
            )  # noqa: E501
        if "with_content" in params:
            query_params.append(("with_content", params["with_content"]))  # noqa: E501
        if "download_policy" in params:
            query_params.append(
                ("download_policy", params["download_policy"])
            )  # noqa: E501
        if "username" in params:
            query_params.append(("username", params["username"]))  # noqa: E501
        if "search" in params:
            query_params.append(("search", params["search"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501
        if "full_result" in params:
            query_params.append(("full_result", params["full_result"]))  # noqa: E501
        if "sort_by" in params:
            query_params.append(("sort_by", params["sort_by"]))  # noqa: E501
        if "sort_order" in params:
            query_params.append(("sort_order", params["sort_order"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/products/{product_id}/repositories",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_repositories(
        self, organization_id, product_id, environment_id, **kwargs
    ):  # noqa: E501
        """List of enabled repositories  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories(organization_id, product_id, environment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float organization_id: ID of an organization to show repositories in (required)
        :param float product_id: ID of a product to show repositories of (required)
        :param float environment_id: ID of an environment to show repositories in (required)
        :param float content_view_id: ID of a content view to show repositories in
        :param float content_view_version_id: ID of a content view version to show repositories in
        :param str deb_id: Id of a deb package to find repositories that contain the deb
        :param str erratum_id: Id of an erratum to find repositories that contain the erratum
        :param str rpm_id: Id of a rpm package to find repositories that contain the rpm
        :param str file_id: Id of a file to find repositories that contain the file
        :param str ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :param bool library: show repositories in Library and the default content view
        :param bool archived: show archived repositories
        :param str content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :param str name: name of the repository
        :param str label: label of the repository
        :param str description: description of the repository
        :param str available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :param str with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :param str download_policy: limit to only repositories with this download policy
        :param str username: only show the repositories readable by this user with this username
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_repositories_with_http_info(
                organization_id, product_id, environment_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_repositories_with_http_info(
                organization_id, product_id, environment_id, **kwargs
            )  # noqa: E501
            return data

    def get_repositories_with_http_info(
        self, organization_id, product_id, environment_id, **kwargs
    ):  # noqa: E501
        """List of enabled repositories  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_with_http_info(organization_id, product_id, environment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float organization_id: ID of an organization to show repositories in (required)
        :param float product_id: ID of a product to show repositories of (required)
        :param float environment_id: ID of an environment to show repositories in (required)
        :param float content_view_id: ID of a content view to show repositories in
        :param float content_view_version_id: ID of a content view version to show repositories in
        :param str deb_id: Id of a deb package to find repositories that contain the deb
        :param str erratum_id: Id of an erratum to find repositories that contain the erratum
        :param str rpm_id: Id of a rpm package to find repositories that contain the rpm
        :param str file_id: Id of a file to find repositories that contain the file
        :param str ansible_collection_id: Id of an ansible collection to find repositories that contain the ansible collection
        :param bool library: show repositories in Library and the default content view
        :param bool archived: show archived repositories
        :param str content_type: Limit the repository type. Available types endpoint: /katello/api/repositories/repository_types
        :param str name: name of the repository
        :param str label: label of the repository
        :param str description: description of the repository
        :param str available_for: interpret specified object to return only Repositories that can be associated with specified object.  Only 'content_view' & 'content_view_version' are supported.
        :param str with_content: Filter repositories by content unit type (erratum, docker_tag, etc.). Check the \"Indexed?\" types here: /katello/api/repositories/repository_types
        :param str download_policy: limit to only repositories with this download policy
        :param str username: only show the repositories readable by this user with this username
        :param str search: Search string
        :param float page: Page number, starting at 1
        :param float per_page: Number of results per page to return
        :param str order: Sort field and order, eg. 'id DESC'
        :param bool full_result: Whether or not to show all results
        :param str sort_by: Field to sort the results on
        :param str sort_order: How to order the sorted results (e.g. ASC for ascending)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "organization_id",
            "product_id",
            "environment_id",
            "content_view_id",
            "content_view_version_id",
            "deb_id",
            "erratum_id",
            "rpm_id",
            "file_id",
            "ansible_collection_id",
            "library",
            "archived",
            "content_type",
            "name",
            "label",
            "description",
            "available_for",
            "with_content",
            "download_policy",
            "username",
            "search",
            "page",
            "per_page",
            "order",
            "full_result",
            "sort_by",
            "sort_order",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and (
            "organization_id" not in params or params["organization_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `organization_id` when calling `get_repositories`"
            )  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and (
            "product_id" not in params or params["product_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `product_id` when calling `get_repositories`"
            )  # noqa: E501
        # verify the required parameter 'environment_id' is set
        if self.api_client.client_side_validation and (
            "environment_id" not in params or params["environment_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `environment_id` when calling `get_repositories`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "organization_id" in params:
            query_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501
        if "product_id" in params:
            query_params.append(("product_id", params["product_id"]))  # noqa: E501
        if "environment_id" in params:
            query_params.append(
                ("environment_id", params["environment_id"])
            )  # noqa: E501
        if "content_view_id" in params:
            query_params.append(
                ("content_view_id", params["content_view_id"])
            )  # noqa: E501
        if "content_view_version_id" in params:
            query_params.append(
                ("content_view_version_id", params["content_view_version_id"])
            )  # noqa: E501
        if "deb_id" in params:
            query_params.append(("deb_id", params["deb_id"]))  # noqa: E501
        if "erratum_id" in params:
            query_params.append(("erratum_id", params["erratum_id"]))  # noqa: E501
        if "rpm_id" in params:
            query_params.append(("rpm_id", params["rpm_id"]))  # noqa: E501
        if "file_id" in params:
            query_params.append(("file_id", params["file_id"]))  # noqa: E501
        if "ansible_collection_id" in params:
            query_params.append(
                ("ansible_collection_id", params["ansible_collection_id"])
            )  # noqa: E501
        if "library" in params:
            query_params.append(("library", params["library"]))  # noqa: E501
        if "archived" in params:
            query_params.append(("archived", params["archived"]))  # noqa: E501
        if "content_type" in params:
            query_params.append(("content_type", params["content_type"]))  # noqa: E501
        if "name" in params:
            query_params.append(("name", params["name"]))  # noqa: E501
        if "label" in params:
            query_params.append(("label", params["label"]))  # noqa: E501
        if "description" in params:
            query_params.append(("description", params["description"]))  # noqa: E501
        if "available_for" in params:
            query_params.append(
                ("available_for", params["available_for"])
            )  # noqa: E501
        if "with_content" in params:
            query_params.append(("with_content", params["with_content"]))  # noqa: E501
        if "download_policy" in params:
            query_params.append(
                ("download_policy", params["download_policy"])
            )  # noqa: E501
        if "username" in params:
            query_params.append(("username", params["username"]))  # noqa: E501
        if "search" in params:
            query_params.append(("search", params["search"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501
        if "full_result" in params:
            query_params.append(("full_result", params["full_result"]))  # noqa: E501
        if "sort_by" in params:
            query_params.append(("sort_by", params["sort_by"]))  # noqa: E501
        if "sort_order" in params:
            query_params.append(("sort_order", params["sort_order"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_repositories_compare(self, **kwargs):  # noqa: E501
        """List :resource  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_compare(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] content_view_version_ids: content view versions to compare
        :param float repository_id: Library repository id to restrict comparisons to
        :param str restrict_comparison: Return same, different or all results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_repositories_compare_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_repositories_compare_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def get_repositories_compare_with_http_info(self, **kwargs):  # noqa: E501
        """List :resource  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_compare_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] content_view_version_ids: content view versions to compare
        :param float repository_id: Library repository id to restrict comparisons to
        :param str restrict_comparison: Return same, different or all results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "content_view_version_ids",
            "repository_id",
            "restrict_comparison",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_compare" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "content_view_version_ids" in params:
            query_params.append(
                ("content_view_version_ids", params["content_view_version_ids"])
            )  # noqa: E501
            collection_formats["content_view_version_ids"] = "csv"  # noqa: E501
        if "repository_id" in params:
            query_params.append(
                ("repository_id", params["repository_id"])
            )  # noqa: E501
        if "restrict_comparison" in params:
            query_params.append(
                ("restrict_comparison", params["restrict_comparison"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/compare",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_repositories_id(self, id, **kwargs):  # noqa: E501
        """Show a repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param float organization_id: Organization ID
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_repositories_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_repositories_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_repositories_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Show a repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param float organization_id: Organization ID
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "organization_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `get_repositories_id`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "organization_id" in params:
            query_params.append(
                ("organization_id", params["organization_id"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_repositories_id_gpg_key_content(self, id, **kwargs):  # noqa: E501
        """Return the content of a repo gpg key, used directly by yum  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_id_gpg_key_content(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_repositories_id_gpg_key_content_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_repositories_id_gpg_key_content_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def get_repositories_id_gpg_key_content_with_http_info(
        self, id, **kwargs
    ):  # noqa: E501
        """Return the content of a repo gpg key, used directly by yum  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_id_gpg_key_content_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_id_gpg_key_content" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `get_repositories_id_gpg_key_content`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/{id}/gpg_key_content",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_repositories_repository_types(self, **kwargs):  # noqa: E501
        """Show the available repository types  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_repository_types(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool creatable: When set to 'True' repository types that are creatable will be returned
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_repositories_repository_types_with_http_info(
                **kwargs
            )  # noqa: E501
        else:
            (data) = self.get_repositories_repository_types_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def get_repositories_repository_types_with_http_info(self, **kwargs):  # noqa: E501
        """Show the available repository types  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_repository_types_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool creatable: When set to 'True' repository types that are creatable will be returned
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["creatable"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_repository_types" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "creatable" in params:
            query_params.append(("creatable", params["creatable"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/repository_types",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_repositories(self, name, product_id, content_type, **kwargs):  # noqa: E501
        """Create a custom repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_repositories(name, product_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Name of the repository (required)
        :param float product_id: Product the repository belongs to (required)
        :param str content_type: Type of repository. Available types endpoint: /katello/api/repositories/repository_types (required)
        :param str description: Description of the repository
        :param str label:
        :param str url: repository source url
        :param list[str] os_versions: Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9
        :param float gpg_key_id: id of the gpg key that will be assigned to the new repository
        :param float ssl_ca_cert_id: Identifier of the content credential containing the SSL CA Cert
        :param float ssl_client_cert_id: Identifier of the content credential containing the SSL Client Cert
        :param float ssl_client_key_id: Identifier of the content credential containing the SSL Client Key
        :param bool unprotected: true if this repository can be published via HTTP
        :param str checksum_type: Checksum of the repository, currently 'sha1' & 'sha256' are supported
        :param str docker_upstream_name: Name of the upstream docker repository
        :param list[str] include_tags: Comma-separated list of tags to sync for a container image repository
        :param list[str] exclude_tags: Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \"-source\"
        :param str download_policy: download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')
        :param float download_concurrency: Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10
        :param str mirroring_policy: Policy to set for mirroring content.  Must be one of additive.
        :param bool verify_ssl_on_sync: if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA
        :param str upstream_username: Username of the upstream repository user used for authentication
        :param str upstream_password: Password of the upstream repository user used for authentication
        :param str upstream_authentication_token: Password of the upstream authentication token.
        :param str deb_releases: whitespace-separated list of releases to be synced from deb-archive
        :param str deb_components: whitespace-separated list of repo components to be synced from deb-archive
        :param str deb_architectures: whitespace-separated list of architectures to be synced from deb-archive
        :param list[str] ignorable_content: List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo
        :param str ansible_collection_requirements: Contents of requirement yaml file to sync from URL
        :param str ansible_collection_auth_url: The URL to receive a session token from, e.g. used with Automation Hub.
        :param str ansible_collection_auth_token: The token key to use for authentication.
        :param str http_proxy_policy: policies for HTTP proxy for content sync
        :param float http_proxy_id: ID of a HTTP Proxy
        :param str arch: Architecture of content in the repository
        :param float retain_package_versions_count: The maximum number of versions of each package to keep.
        :param float metadata_expire: Time to expire yum metadata in seconds. Only relevant for custom yum repositories.
        :param list[str] excludes: Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0.
        :param list[str] includes: Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package.
        :param list[str] package_types: Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_repositories_with_http_info(
                name, product_id, content_type, **kwargs
            )  # noqa: E501
        else:
            (data) = self.post_repositories_with_http_info(
                name, product_id, content_type, **kwargs
            )  # noqa: E501
            return data

    def post_repositories_with_http_info(
        self, name, product_id, content_type, **kwargs
    ):  # noqa: E501
        """Create a custom repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_repositories_with_http_info(name, product_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Name of the repository (required)
        :param float product_id: Product the repository belongs to (required)
        :param str content_type: Type of repository. Available types endpoint: /katello/api/repositories/repository_types (required)
        :param str description: Description of the repository
        :param str label:
        :param str url: repository source url
        :param list[str] os_versions: Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9
        :param float gpg_key_id: id of the gpg key that will be assigned to the new repository
        :param float ssl_ca_cert_id: Identifier of the content credential containing the SSL CA Cert
        :param float ssl_client_cert_id: Identifier of the content credential containing the SSL Client Cert
        :param float ssl_client_key_id: Identifier of the content credential containing the SSL Client Key
        :param bool unprotected: true if this repository can be published via HTTP
        :param str checksum_type: Checksum of the repository, currently 'sha1' & 'sha256' are supported
        :param str docker_upstream_name: Name of the upstream docker repository
        :param list[str] include_tags: Comma-separated list of tags to sync for a container image repository
        :param list[str] exclude_tags: Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \"-source\"
        :param str download_policy: download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')
        :param float download_concurrency: Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10
        :param str mirroring_policy: Policy to set for mirroring content.  Must be one of additive.
        :param bool verify_ssl_on_sync: if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA
        :param str upstream_username: Username of the upstream repository user used for authentication
        :param str upstream_password: Password of the upstream repository user used for authentication
        :param str upstream_authentication_token: Password of the upstream authentication token.
        :param str deb_releases: whitespace-separated list of releases to be synced from deb-archive
        :param str deb_components: whitespace-separated list of repo components to be synced from deb-archive
        :param str deb_architectures: whitespace-separated list of architectures to be synced from deb-archive
        :param list[str] ignorable_content: List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo
        :param str ansible_collection_requirements: Contents of requirement yaml file to sync from URL
        :param str ansible_collection_auth_url: The URL to receive a session token from, e.g. used with Automation Hub.
        :param str ansible_collection_auth_token: The token key to use for authentication.
        :param str http_proxy_policy: policies for HTTP proxy for content sync
        :param float http_proxy_id: ID of a HTTP Proxy
        :param str arch: Architecture of content in the repository
        :param float retain_package_versions_count: The maximum number of versions of each package to keep.
        :param float metadata_expire: Time to expire yum metadata in seconds. Only relevant for custom yum repositories.
        :param list[str] excludes: Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0.
        :param list[str] includes: Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package.
        :param list[str] package_types: Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "name",
            "product_id",
            "content_type",
            "description",
            "label",
            "url",
            "os_versions",
            "gpg_key_id",
            "ssl_ca_cert_id",
            "ssl_client_cert_id",
            "ssl_client_key_id",
            "unprotected",
            "checksum_type",
            "docker_upstream_name",
            "include_tags",
            "exclude_tags",
            "download_policy",
            "download_concurrency",
            "mirroring_policy",
            "verify_ssl_on_sync",
            "upstream_username",
            "upstream_password",
            "upstream_authentication_token",
            "deb_releases",
            "deb_components",
            "deb_architectures",
            "ignorable_content",
            "ansible_collection_requirements",
            "ansible_collection_auth_url",
            "ansible_collection_auth_token",
            "http_proxy_policy",
            "http_proxy_id",
            "arch",
            "retain_package_versions_count",
            "metadata_expire",
            "excludes",
            "includes",
            "package_types",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_repositories" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and (
            "name" not in params or params["name"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `name` when calling `post_repositories`"
            )  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and (
            "product_id" not in params or params["product_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `product_id` when calling `post_repositories`"
            )  # noqa: E501
        # verify the required parameter 'content_type' is set
        if self.api_client.client_side_validation and (
            "content_type" not in params or params["content_type"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `content_type` when calling `post_repositories`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "name" in params:
            form_params.append(("name", params["name"]))  # noqa: E501
        if "product_id" in params:
            form_params.append(("product_id", params["product_id"]))  # noqa: E501
        if "content_type" in params:
            form_params.append(("content_type", params["content_type"]))  # noqa: E501
        if "description" in params:
            form_params.append(("description", params["description"]))  # noqa: E501
        if "label" in params:
            form_params.append(("label", params["label"]))  # noqa: E501
        if "url" in params:
            form_params.append(("url", params["url"]))  # noqa: E501
        if "os_versions" in params:
            form_params.append(("os_versions", params["os_versions"]))  # noqa: E501
            collection_formats["os_versions"] = "csv"  # noqa: E501
        if "gpg_key_id" in params:
            form_params.append(("gpg_key_id", params["gpg_key_id"]))  # noqa: E501
        if "ssl_ca_cert_id" in params:
            form_params.append(
                ("ssl_ca_cert_id", params["ssl_ca_cert_id"])
            )  # noqa: E501
        if "ssl_client_cert_id" in params:
            form_params.append(
                ("ssl_client_cert_id", params["ssl_client_cert_id"])
            )  # noqa: E501
        if "ssl_client_key_id" in params:
            form_params.append(
                ("ssl_client_key_id", params["ssl_client_key_id"])
            )  # noqa: E501
        if "unprotected" in params:
            form_params.append(("unprotected", params["unprotected"]))  # noqa: E501
        if "checksum_type" in params:
            form_params.append(("checksum_type", params["checksum_type"]))  # noqa: E501
        if "docker_upstream_name" in params:
            form_params.append(
                ("docker_upstream_name", params["docker_upstream_name"])
            )  # noqa: E501
        if "include_tags" in params:
            form_params.append(("include_tags", params["include_tags"]))  # noqa: E501
            collection_formats["include_tags"] = "csv"  # noqa: E501
        if "exclude_tags" in params:
            form_params.append(("exclude_tags", params["exclude_tags"]))  # noqa: E501
            collection_formats["exclude_tags"] = "csv"  # noqa: E501
        if "download_policy" in params:
            form_params.append(
                ("download_policy", params["download_policy"])
            )  # noqa: E501
        if "download_concurrency" in params:
            form_params.append(
                ("download_concurrency", params["download_concurrency"])
            )  # noqa: E501
        if "mirroring_policy" in params:
            form_params.append(
                ("mirroring_policy", params["mirroring_policy"])
            )  # noqa: E501
        if "verify_ssl_on_sync" in params:
            form_params.append(
                ("verify_ssl_on_sync", params["verify_ssl_on_sync"])
            )  # noqa: E501
        if "upstream_username" in params:
            form_params.append(
                ("upstream_username", params["upstream_username"])
            )  # noqa: E501
        if "upstream_password" in params:
            form_params.append(
                ("upstream_password", params["upstream_password"])
            )  # noqa: E501
        if "upstream_authentication_token" in params:
            form_params.append(
                (
                    "upstream_authentication_token",
                    params["upstream_authentication_token"],
                )
            )  # noqa: E501
        if "deb_releases" in params:
            form_params.append(("deb_releases", params["deb_releases"]))  # noqa: E501
        if "deb_components" in params:
            form_params.append(
                ("deb_components", params["deb_components"])
            )  # noqa: E501
        if "deb_architectures" in params:
            form_params.append(
                ("deb_architectures", params["deb_architectures"])
            )  # noqa: E501
        if "ignorable_content" in params:
            form_params.append(
                ("ignorable_content", params["ignorable_content"])
            )  # noqa: E501
            collection_formats["ignorable_content"] = "csv"  # noqa: E501
        if "ansible_collection_requirements" in params:
            form_params.append(
                (
                    "ansible_collection_requirements",
                    params["ansible_collection_requirements"],
                )
            )  # noqa: E501
        if "ansible_collection_auth_url" in params:
            form_params.append(
                ("ansible_collection_auth_url", params["ansible_collection_auth_url"])
            )  # noqa: E501
        if "ansible_collection_auth_token" in params:
            form_params.append(
                (
                    "ansible_collection_auth_token",
                    params["ansible_collection_auth_token"],
                )
            )  # noqa: E501
        if "http_proxy_policy" in params:
            form_params.append(
                ("http_proxy_policy", params["http_proxy_policy"])
            )  # noqa: E501
        if "http_proxy_id" in params:
            form_params.append(("http_proxy_id", params["http_proxy_id"]))  # noqa: E501
        if "arch" in params:
            form_params.append(("arch", params["arch"]))  # noqa: E501
        if "retain_package_versions_count" in params:
            form_params.append(
                (
                    "retain_package_versions_count",
                    params["retain_package_versions_count"],
                )
            )  # noqa: E501
        if "metadata_expire" in params:
            form_params.append(
                ("metadata_expire", params["metadata_expire"])
            )  # noqa: E501
        if "excludes" in params:
            form_params.append(("excludes", params["excludes"]))  # noqa: E501
            collection_formats["excludes"] = "csv"  # noqa: E501
        if "includes" in params:
            form_params.append(("includes", params["includes"]))  # noqa: E501
            collection_formats["includes"] = "csv"  # noqa: E501
        if "package_types" in params:
            form_params.append(("package_types", params["package_types"]))  # noqa: E501
            collection_formats["package_types"] = "csv"  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_repositories_id_reclaim_space(self, id, **kwargs):  # noqa: E501
        """Reclaim space from an On Demand repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_repositories_id_reclaim_space(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_repositories_id_reclaim_space_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.post_repositories_id_reclaim_space_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def post_repositories_id_reclaim_space_with_http_info(
        self, id, **kwargs
    ):  # noqa: E501
        """Reclaim space from an On Demand repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_repositories_id_reclaim_space_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_repositories_id_reclaim_space" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `post_repositories_id_reclaim_space`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/{id}/reclaim_space",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_repositories_id_sync(self, id, **kwargs):  # noqa: E501
        """Sync a repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_repositories_id_sync(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param str source_url: temporarily override feed URL for sync
        :param bool incremental: perform an incremental import
        :param bool skip_metadata_check: Force sync even if no upstream changes are detected. Only used with yum or deb repositories.
        :param bool validate_contents: Force a sync and validate the checksums of all content. Only used with yum repositories.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_repositories_id_sync_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.post_repositories_id_sync_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def post_repositories_id_sync_with_http_info(self, id, **kwargs):  # noqa: E501
        """Sync a repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_repositories_id_sync_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param str source_url: temporarily override feed URL for sync
        :param bool incremental: perform an incremental import
        :param bool skip_metadata_check: Force sync even if no upstream changes are detected. Only used with yum or deb repositories.
        :param bool validate_contents: Force a sync and validate the checksums of all content. Only used with yum repositories.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "source_url",
            "incremental",
            "skip_metadata_check",
            "validate_contents",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_repositories_id_sync" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `post_repositories_id_sync`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "source_url" in params:
            form_params.append(("source_url", params["source_url"]))  # noqa: E501
        if "incremental" in params:
            form_params.append(("incremental", params["incremental"]))  # noqa: E501
        if "skip_metadata_check" in params:
            form_params.append(
                ("skip_metadata_check", params["skip_metadata_check"])
            )  # noqa: E501
        if "validate_contents" in params:
            form_params.append(
                ("validate_contents", params["validate_contents"])
            )  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/{id}/sync",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_repositories_id_upload_content(self, id, content, **kwargs):  # noqa: E501
        """Upload content into the repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_repositories_id_upload_content(id, content, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param file content: Content files to upload. Can be a single file or array of files. (required)
        :param str content_type: The type of content to upload (srpm, file, etc.). Check uploadable types here: /katello/api/repositories/repository_types
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_repositories_id_upload_content_with_http_info(
                id, content, **kwargs
            )  # noqa: E501
        else:
            (data) = self.post_repositories_id_upload_content_with_http_info(
                id, content, **kwargs
            )  # noqa: E501
            return data

    def post_repositories_id_upload_content_with_http_info(
        self, id, content, **kwargs
    ):  # noqa: E501
        """Upload content into the repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_repositories_id_upload_content_with_http_info(id, content, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param file content: Content files to upload. Can be a single file or array of files. (required)
        :param str content_type: The type of content to upload (srpm, file, etc.). Check uploadable types here: /katello/api/repositories/repository_types
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "content", "content_type"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_repositories_id_upload_content" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `post_repositories_id_upload_content`"
            )  # noqa: E501
        # verify the required parameter 'content' is set
        if self.api_client.client_side_validation and (
            "content" not in params or params["content"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `content` when calling `post_repositories_id_upload_content`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "content" in params:
            local_var_files["content"] = params["content"]  # noqa: E501
        if "content_type" in params:
            form_params.append(("content_type", params["content_type"]))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/{id}/upload_content",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_repositories_id_verify_checksum(self, id, **kwargs):  # noqa: E501
        """Verify checksum of repository contents  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_repositories_id_verify_checksum(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_repositories_id_verify_checksum_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.post_repositories_id_verify_checksum_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def post_repositories_id_verify_checksum_with_http_info(
        self, id, **kwargs
    ):  # noqa: E501
        """Verify checksum of repository contents  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_repositories_id_verify_checksum_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_repositories_id_verify_checksum" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `post_repositories_id_verify_checksum`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/{id}/verify_checksum",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def put_repositories_id(self, id, **kwargs):  # noqa: E501
        """Update a repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repositories_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param str name:
        :param str description: description of the repository
        :param str url: repository source url
        :param list[str] os_versions: Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9
        :param float gpg_key_id: id of the gpg key that will be assigned to the new repository
        :param float ssl_ca_cert_id: Identifier of the content credential containing the SSL CA Cert
        :param float ssl_client_cert_id: Identifier of the content credential containing the SSL Client Cert
        :param float ssl_client_key_id: Identifier of the content credential containing the SSL Client Key
        :param bool unprotected: true if this repository can be published via HTTP
        :param str checksum_type: Checksum of the repository, currently 'sha1' & 'sha256' are supported
        :param str docker_upstream_name: Name of the upstream docker repository
        :param list[str] include_tags: Comma-separated list of tags to sync for a container image repository
        :param list[str] exclude_tags: Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \"-source\"
        :param str download_policy: download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')
        :param float download_concurrency: Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10
        :param str mirroring_policy: Policy to set for mirroring content.  Must be one of additive.
        :param bool verify_ssl_on_sync: if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA
        :param str upstream_username: Username of the upstream repository user used for authentication
        :param str upstream_password: Password of the upstream repository user used for authentication
        :param str upstream_authentication_token: Password of the upstream authentication token.
        :param str deb_releases: whitespace-separated list of releases to be synced from deb-archive
        :param str deb_components: whitespace-separated list of repo components to be synced from deb-archive
        :param str deb_architectures: whitespace-separated list of architectures to be synced from deb-archive
        :param list[str] ignorable_content: List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo
        :param str ansible_collection_requirements: Contents of requirement yaml file to sync from URL
        :param str ansible_collection_auth_url: The URL to receive a session token from, e.g. used with Automation Hub.
        :param str ansible_collection_auth_token: The token key to use for authentication.
        :param str http_proxy_policy: policies for HTTP proxy for content sync
        :param float http_proxy_id: ID of a HTTP Proxy
        :param str arch: Architecture of content in the repository
        :param float retain_package_versions_count: The maximum number of versions of each package to keep.
        :param float metadata_expire: Time to expire yum metadata in seconds. Only relevant for custom yum repositories.
        :param list[str] excludes: Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0.
        :param list[str] includes: Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package.
        :param list[str] package_types: Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.put_repositories_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_repositories_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def put_repositories_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update a repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repositories_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param str name:
        :param str description: description of the repository
        :param str url: repository source url
        :param list[str] os_versions: Identifies whether the repository should be unavailable on a client with a non-matching OS version. Pass [] to make repo available for clients regardless of OS version. Maximum length 1; allowed tags are: rhel-6, rhel-7, rhel-8, rhel-9
        :param float gpg_key_id: id of the gpg key that will be assigned to the new repository
        :param float ssl_ca_cert_id: Identifier of the content credential containing the SSL CA Cert
        :param float ssl_client_cert_id: Identifier of the content credential containing the SSL Client Cert
        :param float ssl_client_key_id: Identifier of the content credential containing the SSL Client Key
        :param bool unprotected: true if this repository can be published via HTTP
        :param str checksum_type: Checksum of the repository, currently 'sha1' & 'sha256' are supported
        :param str docker_upstream_name: Name of the upstream docker repository
        :param list[str] include_tags: Comma-separated list of tags to sync for a container image repository
        :param list[str] exclude_tags: Comma-separated list of tags to exclude when syncing a container image repository. Default: any tag ending in \"-source\"
        :param str download_policy: download policy for yum, deb, and docker repos (either 'immediate' or 'on_demand')
        :param float download_concurrency: Used to determine download concurrency of the repository in pulp3. Use value less than 20. Defaults to 10
        :param str mirroring_policy: Policy to set for mirroring content.  Must be one of additive.
        :param bool verify_ssl_on_sync: if true, Katello will verify the upstream url's SSL certifcates are signed by a trusted CA
        :param str upstream_username: Username of the upstream repository user used for authentication
        :param str upstream_password: Password of the upstream repository user used for authentication
        :param str upstream_authentication_token: Password of the upstream authentication token.
        :param str deb_releases: whitespace-separated list of releases to be synced from deb-archive
        :param str deb_components: whitespace-separated list of repo components to be synced from deb-archive
        :param str deb_architectures: whitespace-separated list of architectures to be synced from deb-archive
        :param list[str] ignorable_content: List of content units to ignore while syncing a yum repository. Must be subset of srpm,treeinfo
        :param str ansible_collection_requirements: Contents of requirement yaml file to sync from URL
        :param str ansible_collection_auth_url: The URL to receive a session token from, e.g. used with Automation Hub.
        :param str ansible_collection_auth_token: The token key to use for authentication.
        :param str http_proxy_policy: policies for HTTP proxy for content sync
        :param float http_proxy_id: ID of a HTTP Proxy
        :param str arch: Architecture of content in the repository
        :param float retain_package_versions_count: The maximum number of versions of each package to keep.
        :param float metadata_expire: Time to expire yum metadata in seconds. Only relevant for custom yum repositories.
        :param list[str] excludes: Python packages to exclude from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0.
        :param list[str] includes: Python packages to include from the upstream URL, names separated by newline. You may also specify versions, for example: django~=2.0. Leave empty to include every package.
        :param list[str] package_types: Package types to sync for Python content, separated by comma. Leave empty to get every package type. Package types are: bdist_dmg, bdist_dumb, bdist_egg, bdist_msi, bdist_rpm, bdist_wheel, bdist_wininst, sdist.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "name",
            "description",
            "url",
            "os_versions",
            "gpg_key_id",
            "ssl_ca_cert_id",
            "ssl_client_cert_id",
            "ssl_client_key_id",
            "unprotected",
            "checksum_type",
            "docker_upstream_name",
            "include_tags",
            "exclude_tags",
            "download_policy",
            "download_concurrency",
            "mirroring_policy",
            "verify_ssl_on_sync",
            "upstream_username",
            "upstream_password",
            "upstream_authentication_token",
            "deb_releases",
            "deb_components",
            "deb_architectures",
            "ignorable_content",
            "ansible_collection_requirements",
            "ansible_collection_auth_url",
            "ansible_collection_auth_token",
            "http_proxy_policy",
            "http_proxy_id",
            "arch",
            "retain_package_versions_count",
            "metadata_expire",
            "excludes",
            "includes",
            "package_types",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_repositories_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `put_repositories_id`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "name" in params:
            form_params.append(("name", params["name"]))  # noqa: E501
        if "description" in params:
            form_params.append(("description", params["description"]))  # noqa: E501
        if "url" in params:
            form_params.append(("url", params["url"]))  # noqa: E501
        if "os_versions" in params:
            form_params.append(("os_versions", params["os_versions"]))  # noqa: E501
            collection_formats["os_versions"] = "csv"  # noqa: E501
        if "gpg_key_id" in params:
            form_params.append(("gpg_key_id", params["gpg_key_id"]))  # noqa: E501
        if "ssl_ca_cert_id" in params:
            form_params.append(
                ("ssl_ca_cert_id", params["ssl_ca_cert_id"])
            )  # noqa: E501
        if "ssl_client_cert_id" in params:
            form_params.append(
                ("ssl_client_cert_id", params["ssl_client_cert_id"])
            )  # noqa: E501
        if "ssl_client_key_id" in params:
            form_params.append(
                ("ssl_client_key_id", params["ssl_client_key_id"])
            )  # noqa: E501
        if "unprotected" in params:
            form_params.append(("unprotected", params["unprotected"]))  # noqa: E501
        if "checksum_type" in params:
            form_params.append(("checksum_type", params["checksum_type"]))  # noqa: E501
        if "docker_upstream_name" in params:
            form_params.append(
                ("docker_upstream_name", params["docker_upstream_name"])
            )  # noqa: E501
        if "include_tags" in params:
            form_params.append(("include_tags", params["include_tags"]))  # noqa: E501
            collection_formats["include_tags"] = "csv"  # noqa: E501
        if "exclude_tags" in params:
            form_params.append(("exclude_tags", params["exclude_tags"]))  # noqa: E501
            collection_formats["exclude_tags"] = "csv"  # noqa: E501
        if "download_policy" in params:
            form_params.append(
                ("download_policy", params["download_policy"])
            )  # noqa: E501
        if "download_concurrency" in params:
            form_params.append(
                ("download_concurrency", params["download_concurrency"])
            )  # noqa: E501
        if "mirroring_policy" in params:
            form_params.append(
                ("mirroring_policy", params["mirroring_policy"])
            )  # noqa: E501
        if "verify_ssl_on_sync" in params:
            form_params.append(
                ("verify_ssl_on_sync", params["verify_ssl_on_sync"])
            )  # noqa: E501
        if "upstream_username" in params:
            form_params.append(
                ("upstream_username", params["upstream_username"])
            )  # noqa: E501
        if "upstream_password" in params:
            form_params.append(
                ("upstream_password", params["upstream_password"])
            )  # noqa: E501
        if "upstream_authentication_token" in params:
            form_params.append(
                (
                    "upstream_authentication_token",
                    params["upstream_authentication_token"],
                )
            )  # noqa: E501
        if "deb_releases" in params:
            form_params.append(("deb_releases", params["deb_releases"]))  # noqa: E501
        if "deb_components" in params:
            form_params.append(
                ("deb_components", params["deb_components"])
            )  # noqa: E501
        if "deb_architectures" in params:
            form_params.append(
                ("deb_architectures", params["deb_architectures"])
            )  # noqa: E501
        if "ignorable_content" in params:
            form_params.append(
                ("ignorable_content", params["ignorable_content"])
            )  # noqa: E501
            collection_formats["ignorable_content"] = "csv"  # noqa: E501
        if "ansible_collection_requirements" in params:
            form_params.append(
                (
                    "ansible_collection_requirements",
                    params["ansible_collection_requirements"],
                )
            )  # noqa: E501
        if "ansible_collection_auth_url" in params:
            form_params.append(
                ("ansible_collection_auth_url", params["ansible_collection_auth_url"])
            )  # noqa: E501
        if "ansible_collection_auth_token" in params:
            form_params.append(
                (
                    "ansible_collection_auth_token",
                    params["ansible_collection_auth_token"],
                )
            )  # noqa: E501
        if "http_proxy_policy" in params:
            form_params.append(
                ("http_proxy_policy", params["http_proxy_policy"])
            )  # noqa: E501
        if "http_proxy_id" in params:
            form_params.append(("http_proxy_id", params["http_proxy_id"]))  # noqa: E501
        if "arch" in params:
            form_params.append(("arch", params["arch"]))  # noqa: E501
        if "retain_package_versions_count" in params:
            form_params.append(
                (
                    "retain_package_versions_count",
                    params["retain_package_versions_count"],
                )
            )  # noqa: E501
        if "metadata_expire" in params:
            form_params.append(
                ("metadata_expire", params["metadata_expire"])
            )  # noqa: E501
        if "excludes" in params:
            form_params.append(("excludes", params["excludes"]))  # noqa: E501
            collection_formats["excludes"] = "csv"  # noqa: E501
        if "includes" in params:
            form_params.append(("includes", params["includes"]))  # noqa: E501
            collection_formats["includes"] = "csv"  # noqa: E501
        if "package_types" in params:
            form_params.append(("package_types", params["package_types"]))  # noqa: E501
            collection_formats["package_types"] = "csv"  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/{id}",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def put_repositories_id_import_uploads(self, id, **kwargs):  # noqa: E501
        """Import uploads into a repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repositories_id_import_uploads(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: Repository id (required)
        :param bool _async: Do not wait for the ImportUpload action to finish. Default: false
        :param bool publish_repository: Whether or not to regenerate the repository on disk. Default: true
        :param bool sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :param str content_type: content type ('deb', 'docker_manifest', 'file', 'ostree_ref', 'rpm', 'srpm')
        :param list[str] uploads: Array of uploads to import
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.put_repositories_id_import_uploads_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.put_repositories_id_import_uploads_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def put_repositories_id_import_uploads_with_http_info(
        self, id, **kwargs
    ):  # noqa: E501
        """Import uploads into a repository  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repositories_id_import_uploads_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: Repository id (required)
        :param bool _async: Do not wait for the ImportUpload action to finish. Default: false
        :param bool publish_repository: Whether or not to regenerate the repository on disk. Default: true
        :param bool sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :param str content_type: content type ('deb', 'docker_manifest', 'file', 'ostree_ref', 'rpm', 'srpm')
        :param list[str] uploads: Array of uploads to import
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "_async",
            "publish_repository",
            "sync_capsule",
            "content_type",
            "uploads",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_repositories_id_import_uploads" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `put_repositories_id_import_uploads`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "_async" in params:
            form_params.append(("async", params["_async"]))  # noqa: E501
        if "publish_repository" in params:
            form_params.append(
                ("publish_repository", params["publish_repository"])
            )  # noqa: E501
        if "sync_capsule" in params:
            form_params.append(("sync_capsule", params["sync_capsule"]))  # noqa: E501
        if "content_type" in params:
            form_params.append(("content_type", params["content_type"]))  # noqa: E501
        if "uploads" in params:
            form_params.append(("uploads", params["uploads"]))  # noqa: E501
            collection_formats["uploads"] = "csv"  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/{id}/import_uploads",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def put_repositories_id_remove_content(self, id, ids, **kwargs):  # noqa: E501
        """put_repositories_id_remove_content  # noqa: E501

        Remove content from a repository  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repositories_id_remove_content(id, ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param list[str] ids: Array of content ids to remove (required)
        :param str content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :param bool sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.put_repositories_id_remove_content_with_http_info(
                id, ids, **kwargs
            )  # noqa: E501
        else:
            (data) = self.put_repositories_id_remove_content_with_http_info(
                id, ids, **kwargs
            )  # noqa: E501
            return data

    def put_repositories_id_remove_content_with_http_info(
        self, id, ids, **kwargs
    ):  # noqa: E501
        """put_repositories_id_remove_content  # noqa: E501

        Remove content from a repository  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repositories_id_remove_content_with_http_info(id, ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param list[str] ids: Array of content ids to remove (required)
        :param str content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :param bool sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "ids", "content_type", "sync_capsule"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_repositories_id_remove_content" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `put_repositories_id_remove_content`"
            )  # noqa: E501
        # verify the required parameter 'ids' is set
        if self.api_client.client_side_validation and (
            "ids" not in params or params["ids"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `ids` when calling `put_repositories_id_remove_content`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "ids" in params:
            form_params.append(("ids", params["ids"]))  # noqa: E501
            collection_formats["ids"] = "csv"  # noqa: E501
        if "content_type" in params:
            form_params.append(("content_type", params["content_type"]))  # noqa: E501
        if "sync_capsule" in params:
            form_params.append(("sync_capsule", params["sync_capsule"]))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/{id}/remove_content",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def put_repositories_id_remove_docker_manifests(
        self, id, ids, **kwargs
    ):  # noqa: E501
        """put_repositories_id_remove_docker_manifests  # noqa: E501

        Remove content from a repository  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repositories_id_remove_docker_manifests(id, ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param list[str] ids: Array of content ids to remove (required)
        :param str content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :param bool sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.put_repositories_id_remove_docker_manifests_with_http_info(
                id, ids, **kwargs
            )  # noqa: E501
        else:
            (data) = self.put_repositories_id_remove_docker_manifests_with_http_info(
                id, ids, **kwargs
            )  # noqa: E501
            return data

    def put_repositories_id_remove_docker_manifests_with_http_info(
        self, id, ids, **kwargs
    ):  # noqa: E501
        """put_repositories_id_remove_docker_manifests  # noqa: E501

        Remove content from a repository  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repositories_id_remove_docker_manifests_with_http_info(id, ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param list[str] ids: Array of content ids to remove (required)
        :param str content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :param bool sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "ids", "content_type", "sync_capsule"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_repositories_id_remove_docker_manifests" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `put_repositories_id_remove_docker_manifests`"
            )  # noqa: E501
        # verify the required parameter 'ids' is set
        if self.api_client.client_side_validation and (
            "ids" not in params or params["ids"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `ids` when calling `put_repositories_id_remove_docker_manifests`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "ids" in params:
            form_params.append(("ids", params["ids"]))  # noqa: E501
            collection_formats["ids"] = "csv"  # noqa: E501
        if "content_type" in params:
            form_params.append(("content_type", params["content_type"]))  # noqa: E501
        if "sync_capsule" in params:
            form_params.append(("sync_capsule", params["sync_capsule"]))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/{id}/remove_docker_manifests",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def put_repositories_id_remove_packages(self, id, ids, **kwargs):  # noqa: E501
        """put_repositories_id_remove_packages  # noqa: E501

        Remove content from a repository  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repositories_id_remove_packages(id, ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param list[str] ids: Array of content ids to remove (required)
        :param str content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :param bool sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.put_repositories_id_remove_packages_with_http_info(
                id, ids, **kwargs
            )  # noqa: E501
        else:
            (data) = self.put_repositories_id_remove_packages_with_http_info(
                id, ids, **kwargs
            )  # noqa: E501
            return data

    def put_repositories_id_remove_packages_with_http_info(
        self, id, ids, **kwargs
    ):  # noqa: E501
        """put_repositories_id_remove_packages  # noqa: E501

        Remove content from a repository  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repositories_id_remove_packages_with_http_info(id, ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: repository ID (required)
        :param list[str] ids: Array of content ids to remove (required)
        :param str content_type: The type of content to remove (srpm, docker_manifest, etc.). Check removable types here: /katello/api/repositories/repository_types
        :param bool sync_capsule: Whether or not to sync an external capsule after upload. Default: true
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "ids", "content_type", "sync_capsule"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_repositories_id_remove_packages" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `put_repositories_id_remove_packages`"
            )  # noqa: E501
        # verify the required parameter 'ids' is set
        if self.api_client.client_side_validation and (
            "ids" not in params or params["ids"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `ids` when calling `put_repositories_id_remove_packages`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "ids" in params:
            form_params.append(("ids", params["ids"]))  # noqa: E501
            collection_formats["ids"] = "csv"  # noqa: E501
        if "content_type" in params:
            form_params.append(("content_type", params["content_type"]))  # noqa: E501
        if "sync_capsule" in params:
            form_params.append(("sync_capsule", params["sync_capsule"]))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/{id}/remove_packages",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def put_repositories_id_republish(self, id, **kwargs):  # noqa: E501
        """Forces a republish of the specified repository, regenerating metadata and symlinks on the filesystem. Not allowed for repositories with the 'Complete Mirroring' mirroring policy.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repositories_id_republish(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: Repository identifier (required)
        :param bool force: Force metadata regeneration to proceed. Dangerous when repositories use the 'Complete Mirroring' mirroring policy
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.put_repositories_id_republish_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.put_repositories_id_republish_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def put_repositories_id_republish_with_http_info(self, id, **kwargs):  # noqa: E501
        """Forces a republish of the specified repository, regenerating metadata and symlinks on the filesystem. Not allowed for repositories with the 'Complete Mirroring' mirroring policy.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repositories_id_republish_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: Repository identifier (required)
        :param bool force: Force metadata regeneration to proceed. Dangerous when repositories use the 'Complete Mirroring' mirroring policy
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "force"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_repositories_id_republish" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `put_repositories_id_republish`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "force" in params:
            form_params.append(("force", params["force"]))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/x-www-form-urlencoded", "multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/repositories/{id}/republish",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
